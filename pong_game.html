<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D COSMIC PONG ARENA</title>
  <!-- Three.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- Socket.io for multiplayer -->
  <script src="https://cdn.socket.io/4.4.1/socket.io.min.js"></script>
  <!-- GSAP for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
  <!-- TweenMax for advanced animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenMax.min.js"></script>
  <!-- Howler.js for sound -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
  <!-- PayPal SDK -->
  <script src="https://www.paypal.com/sdk/js?client-id=test&currency=USD"></script>
  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Russo+One&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --primary: #00fcff;
      --primary-dark: #0083b0;
      --secondary: #ff00ff;
      --tertiary: #ffff00;
      --background: #0f0f2a;
      --text: #ffffff;
      --panel: rgba(0, 20, 40, 0.85);
      --accent: #ff00ff;
      --success: #00ff66;
      --warning: #ffcc00;
      --danger: #ff3366;
    }
    
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      background: radial-gradient(ellipse at center, #1a0033 0%, #000033 100%);
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      color: var(--text);
      overflow: hidden;
      position: relative;
    }
    
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      height: 100vh;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    
    /* 3D canvas container */
    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
      outline: none;
    }
    
    /* Loading screen */
    #loadingScreen {
      position: fixed;
      z-index: 9999;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--background);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 1s ease-out;
    }
    
    .loading-logo {
      width: 200px;
      height: 200px;
      margin-bottom: 30px;
      animation: pulse 2s infinite;
    }
    
    .loading-bar-container {
      width: 300px;
      height: 30px;
      background: rgba(255,255,255,0.1);
      border-radius: 15px;
      overflow: hidden;
      padding: 4px;
      box-shadow: 0 0 20px var(--accent);
    }
    
    .loading-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--primary) 0%, var(--accent) 100%);
      border-radius: 10px;
      transition: width 0.3s ease;
    }
    
    .loading-text {
      margin-top: 20px;
      font-size: 24px;
      font-family: 'Orbitron', sans-serif;
      color: var(--primary);
      text-shadow: 0 0 10px var(--primary);
    }
    
    /* Main UI layer */
    .ui-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
      pointer-events: none;
      display: flex;
      flex-direction: column;
    }
    
    /* All UI panels */
    .ui-panel {
      pointer-events: auto;
      background: var(--panel);
      border: 2px solid var(--primary);
      border-radius: 12px;
      box-shadow: 0 0 30px rgba(0, 252, 255, 0.3);
      backdrop-filter: blur(10px);
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      overflow: hidden;
    }
    
    .panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: rgba(0, 0, 40, 0.6);
      border-bottom: 2px solid var(--primary);
    }
    
    .panel-title {
      font-size: 24px;
      font-weight: 700;
      font-family: 'Russo One', sans-serif;
      margin: 0;
      background: linear-gradient(to right, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 5px rgba(0, 252, 255, 0.5);
    }
    
    .panel-content {
      padding: 20px;
      max-height: 70vh;
      overflow-y: auto;
      scrollbar-width: thin;
    }
    
    /* Main menu screen */
    #mainMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 600px;
      z-index: 10;
      display: none;
    }
    
    /* Game HUD elements */
    .game-hud {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
    }
    
    /* Game Score Display */
    .score-container {
      display: flex;
      justify-content: center;
      position: absolute;
      top: 20px;
      left: 0;
      right: 0;
      pointer-events: none;
    }
    
    #scores {
      font-size: 36px;
      font-weight: 900;
      text-align: center;
      padding: 10px 30px;
      background: rgba(0, 10, 30, 0.7);
      border-radius: 20px;
      box-shadow: 0 0 20px rgba(0, 252, 255, 0.5);
      text-shadow: 0 0 15px var(--primary);
      font-family: 'Russo One', sans-serif;
      border: 2px solid var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      min-width: 250px;
    }
    
    /* Player scores with team colors */
    .player-score {
      margin: 0 15px;
      padding: 5px 15px;
      min-width: 60px;
      text-align: center;
      position: relative;
    }
    
    .player-score.left {
      color: var(--primary);
    }
    
    .player-score.right {
      color: var(--secondary);
    }
    
    /* Buttons and controls */
    .btn-group {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }
    
    .cyber-button {
      --button-color: var(--primary);
      --button-color-dark: var(--primary-dark);
      --button-text: var(--text);
      
      background: transparent;
      color: var(--button-text);
      font-family: 'Orbitron', sans-serif;
      font-weight: 700;
      font-size: 16px;
      text-transform: uppercase;
      letter-spacing: 1px;
      padding: 12px 24px;
      min-width: 150px;
      border: 2px solid var(--button-color);
      border-radius: 8px;
      position: relative;
      cursor: pointer;
      overflow: hidden;
      transition: all 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      box-shadow: 0 0 10px var(--button-color), 
                 inset 0 0 5px var(--button-color);
      outline: none;
      z-index: 1;
    }
    
    .cyber-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--button-color);
      transform: scaleX(0);
      transform-origin: right;
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      z-index: -1;
    }
    
    .cyber-button:hover {
      color: var(--background);
      text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 20px var(--button-color);
      transform: translateY(-2px);
    }
    
    .cyber-button:hover::before {
      transform: scaleX(1);
      transform-origin: left;
    }
    
    .cyber-button.active {
      --button-color: var(--success);
      --button-color-dark: #00cc33;
      background: var(--button-color);
      color: var(--background);
      font-weight: 900;
    }
    
    .cyber-button.secondary {
      --button-color: var(--secondary);
      --button-color-dark: #cc00cc;
    }
    
    .cyber-button.warning {
      --button-color: var(--warning);
      --button-color-dark: #cc9900;
    }
    
    .cyber-button.danger {
      --button-color: var(--danger);
      --button-color-dark: #cc0033;
    }
    
    /* Settings panels */
    .settings-section {
      margin-bottom: 25px;
      border-bottom: 1px solid rgba(0, 252, 255, 0.3);
      padding-bottom: 15px;
    }
    
    .settings-section:last-child {
      border-bottom: none;
    }
    
    .settings-section h3 {
      margin: 0 0 15px 0;
      font-size: 20px;
      padding-bottom: 10px;
      position: relative;
      color: var(--primary);
      text-shadow: 0 0 5px var(--primary);
    }
    
    .settings-section h3::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100px;
      height: 3px;
      background: linear-gradient(90deg, var(--primary), transparent);
    }
    
    .settings-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 15px;
      width: 100%;
    }
    
    .settings-row {
      display: flex;
      align-items: center;
      margin-bottom: 12px;
      position: relative;
      padding: 8px;
      border-radius: 8px;
      transition: all 0.2s ease;
    }
    
    .settings-row:hover {
      background: rgba(0, 252, 255, 0.1);
    }
    
    .settings-row label {
      flex: 1;
      margin: 0;
      font-size: 16px;
      cursor: pointer;
    }
    
    /* Futuristic form elements */
    input[type="number"], select {
      width: 90px;
      padding: 10px 15px;
      border-radius: 6px;
      border: 1px solid var(--primary);
      background: rgba(0, 20, 40, 0.6);
      color: var(--text);
      margin-left: 10px;
      font-family: 'Orbitron', sans-serif;
      font-size: 14px;
      outline: none;
      transition: all 0.2s ease;
      box-shadow: 0 0 5px rgba(0, 252, 255, 0.3);
    }
    
    input[type="number"]:focus, select:focus {
      border-color: var(--secondary);
      box-shadow: 0 0 15px rgba(255, 0, 255, 0.5);
    }
    
    /* Custom checkboxes */
    .cyber-checkbox {
      position: relative;
      display: flex;
      align-items: center;
      cursor: pointer;
      padding: 5px 0;
    }
    
    .cyber-checkbox input {
      position: absolute;
      opacity: 0;
      cursor: pointer;
      height: 0;
      width: 0;
    }
    
    .checkmark {
      height: 22px;
      width: 22px;
      background: rgba(0, 20, 40, 0.6);
      border: 2px solid var(--primary);
      border-radius: 4px;
      margin-right: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      box-shadow: 0 0 5px rgba(0, 252, 255, 0.3);
    }
    
    .cyber-checkbox:hover .checkmark {
      background: rgba(0, 252, 255, 0.1);
    }
    
    .cyber-checkbox input:checked ~ .checkmark {
      background: var(--primary);
      border-color: var(--text);
    }
    
    .checkmark:after {
      content: "";
      position: absolute;
      display: none;
      width: 6px;
      height: 12px;
      border: solid var(--background);
      border-width: 0 3px 3px 0;
      transform: rotate(45deg);
    }
    
    .cyber-checkbox input:checked ~ .checkmark:after {
      display: block;
    }
    
    /* Cyber slider */
    .cyber-slider {
      display: flex;
      align-items: center;
      width: 100%;
      margin: 15px 0;
    }
    
    .cyber-slider label {
      margin-right: 15px;
      min-width: 120px;
    }
    
    .slider-container {
      flex: 1;
      position: relative;
    }
    
    .slider {
      -webkit-appearance: none;
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: rgba(0, 20, 40, 0.6);
      border: 1px solid var(--primary);
      outline: none;
      transition: all 0.2s ease;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      box-shadow: 0 0 10px var(--primary);
      transition: all 0.2s ease;
    }
    
    .slider::-moz-range-thumb {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--primary);
      cursor: pointer;
      box-shadow: 0 0 10px var(--primary);
      transition: all 0.2s ease;
    }
    
    .slider:hover::-webkit-slider-thumb {
      background: var(--secondary);
      box-shadow: 0 0 15px var(--secondary);
    }
    
    .slider-value {
      margin-left: 15px;
      min-width: 50px;
      text-align: center;
      font-family: 'Orbitron', sans-serif;
      color: var(--primary);
      font-weight: bold;
    }
    
    /* Controls help section */
    .controls-help {
      background: rgba(0, 20, 40, 0.7);
      border-radius: 10px;
      padding: 15px 20px;
      margin-top: 20px;
      border: 1px solid var(--primary);
      box-shadow: 0 0 15px rgba(0, 252, 255, 0.2);
    }
    
    .controls-help h4 {
      margin: 0 0 15px 0;
      font-size: 18px;
      color: var(--primary);
      text-shadow: 0 0 5px var(--primary);
    }
    
    .controls-help p {
      margin: 8px 0;
      font-size: 15px;
      display: flex;
      align-items: center;
    }
    
    .key {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 252, 255, 0.1);
      border: 1px solid var(--primary);
      padding: 5px 12px;
      border-radius: 6px;
      margin: 0 5px;
      min-width: 30px;
      height: 30px;
      box-shadow: 0 0 5px rgba(0, 252, 255, 0.3);
      font-family: 'Orbitron', sans-serif;
      font-weight: bold;
    }
    
    /* Scrollbar styling */
    ::-webkit-scrollbar {
      width: 10px;
    }
    
    ::-webkit-scrollbar-track {
      background: rgba(0, 20, 40, 0.5);
      border-radius: 5px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(to bottom, var(--primary), var(--secondary));
      border-radius: 5px;
      border: 2px solid rgba(0, 20, 40, 0.5);
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(to bottom, var(--secondary), var(--primary));
    }
    
    /* Animations */
    @keyframes pulse {
      0% { transform: scale(1); opacity: 1; }
      50% { transform: scale(1.05); opacity: 0.8; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
      100% { transform: translateY(0px); }
    }
    
    @keyframes glow {
      0% { box-shadow: 0 0 5px var(--primary); }
      50% { box-shadow: 0 0 20px var(--primary), 0 0 30px var(--secondary); }
      100% { box-shadow: 0 0 5px var(--primary); }
    }
    
    @keyframes rotateHue {
      0% { filter: hue-rotate(0deg); }
      100% { filter: hue-rotate(360deg); }
    }
    
    /* Store items styling */
    .store-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 20px;
    }
    
    .store-item {
      background: rgba(0, 20, 40, 0.7);
      border: 2px solid var(--primary);
      border-radius: 10px;
      padding: 15px;
      display: flex;
      flex-direction: column;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    
    .store-item:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3), 0 0 15px var(--primary);
      border-color: var(--secondary);
    }
    
    .store-item-image {
      height: 120px;
      background: rgba(0, 10, 30, 0.7);
      border-radius: 8px;
      margin-bottom: 15px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    
    .store-item-title {
      font-size: 18px;
      font-weight: bold;
      margin: 0 0 10px 0;
      color: var(--primary);
    }
    
    .store-item-description {
      font-size: 14px;
      margin-bottom: 15px;
      flex-grow: 1;
    }
    
    .store-item-price {
      font-size: 20px;
      font-weight: bold;
      color: var(--tertiary);
      margin-bottom: 15px;
      display: flex;
      align-items: center;
    }
    
    .currency-icon {
      margin-right: 5px;
      font-size: 18px;
    }
    
    /* Game modes panel */
    #gameModePanel {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      min-width: 300px;
      z-index: 100;
    }
    
    /* Notifications */
    .notification-container {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 300px;
      z-index: 9999;
    }
    
    .notification {
      background: rgba(0, 20, 40, 0.9);
      border-left: 4px solid var(--primary);
      margin-bottom: 10px;
      padding: 15px;
      border-radius: 6px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      transform: translateX(120%);
      transition: transform 0.3s cubic-bezier(0.16, 1, 0.3, 1);
      display: flex;
      align-items: center;
    }
    
    .notification.show {
      transform: translateX(0);
    }
    
    .notification-icon {
      margin-right: 15px;
      font-size: 20px;
      color: var(--primary);
    }
    
    .notification-content {
      flex: 1;
    }
    
    .notification-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .notification-message {
      font-size: 14px;
      opacity: 0.9;
    }
    
    .notification.success {
      border-left-color: var(--success);
    }
    
    .notification.success .notification-icon {
      color: var(--success);
    }
    
    .notification.warning {
      border-left-color: var(--warning);
    }
    
    .notification.warning .notification-icon {
      color: var(--warning);
    }
    
    .notification.error {
      border-left-color: var(--danger);
    }
    
    .notification.error .notification-icon {
      color: var(--danger);
    }
    
    /* Power-up display effects */
    .power-up-display {
      position: absolute;
      height: 100%;
      width: 100px;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      align-items: center;
      padding-top: 100px;
    }
    
    .power-up-display.left {
      left: 10px;
    }
    
    .power-up-display.right {
      right: 10px;
    }
    
    .power-up-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 60px;
      height: 60px;
      margin-bottom: 10px;
      border-radius: 50%;
      background: rgba(0, 20, 40, 0.8);
      border: 2px solid;
      position: relative;
      animation: pulse 2s infinite;
    }
    
    .power-up-icon::after {
      content: '';
      position: absolute;
      top: -5px;
      right: -5px;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      background: var(--panel);
      border: 2px solid;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
    }
    
    /* Multiplayer lobby */
    .lobby-container {
      width: 100%;
      max-width: 800px;
    }
    
    .player-list {
      margin: 20px 0;
    }
    
    .player-item {
      display: flex;
      align-items: center;
      padding: 15px;
      background: rgba(0, 20, 40, 0.5);
      border-radius: 8px;
      margin-bottom: 10px;
      transition: all 0.2s ease;
      border-left: 4px solid var(--primary);
    }
    
    .player-item:hover {
      background: rgba(0, 20, 40, 0.7);
      transform: translateX(5px);
    }
    
    .player-avatar {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      margin-right: 15px;
      background: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: bold;
      color: var(--background);
    }
    
    .player-info {
      flex: 1;
    }
    
    .player-name {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .player-status {
      font-size: 14px;
      color: var(--tertiary);
    }
    
    .player-stats {
      display: flex;
      align-items: center;
      gap: 15px;
    }
    
    .player-stat {
      display: flex;
      align-items: center;
    }
    
    .player-stat i {
      margin-right: 5px;
      color: var(--primary);
    }
    
    /* PayPal button styling */
    #paypal-button-container {
      width: 100%;
      margin-top: 20px;
    }
    
    /* Mobile and responsive styles */
    @media (max-width: 1100px) {
      .ui-panel {
        width: 90% !important;
        max-width: 90% !important;
      }
      
      #mainMenu {
        width: 90%;
        max-width: 500px;
      }
      
      .settings-grid {
        grid-template-columns: 1fr;
      }
      
      .cyber-slider {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .cyber-slider label {
        margin-bottom: 10px;
      }
      
      .slider-container {
        width: 100%;
      }
    }
    
    @media (max-width: 768px) {
      .score-container {
        top: 10px;
      }
      
      #scores {
        font-size: 26px;
        padding: 8px 20px;
      }
      
      .btn-group {
        flex-direction: column;
        align-items: center;
      }
      
      .cyber-button {
        width: 100%;
      }
      
      .store-grid {
        grid-template-columns: 1fr;
      }
      
      .game-hud {
        pointer-events: none;
      }
      
      /* Mobile controls */
      .mobile-controls {
        display: flex;
        position: absolute;
        bottom: 20px;
        left: 0;
        width: 100%;
        justify-content: space-between;
        padding: 0 20px;
        pointer-events: all;
      }
      
      .mobile-control {
        width: 80px;
        height: 80px;
        background: rgba(0, 20, 40, 0.6);
        border: 2px solid var(--primary);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 30px;
        color: var(--primary);
        touch-action: manipulation;
      }
      
      .mobile-control:active {
        background: rgba(0, 252, 255, 0.2);
        transform: scale(1.1);
      }
    }
    
    /* Landscape mode adjustments */
    @media (max-height: 600px) and (orientation: landscape) {
      .mobile-controls {
        bottom: 10px;
      }
      
      .mobile-control {
        width: 60px;
        height: 60px;
        font-size: 24px;
      }
    }
  </style>
</head>
<body>
  <!-- Loading Screen -->
  <div id="loadingScreen">
    <div class="loading-logo">
      <svg width="200" height="200" viewBox="0 0 200 200">
        <circle cx="100" cy="100" r="80" fill="none" stroke="#00fcff" stroke-width="8" stroke-dasharray="502" stroke-dashoffset="502">
          <animate attributeName="stroke-dashoffset" from="502" to="0" dur="2s" begin="0s" fill="freeze" />
        </circle>
        <rect x="30" y="80" width="30" height="80" rx="5" fill="#00fcff">
          <animate attributeName="y" from="200" to="80" dur="0.5s" begin="1s" fill="freeze" />
        </rect>
        <rect x="140" y="40" width="30" height="80" rx="5" fill="#ff00ff">
          <animate attributeName="y" from="-80" to="40" dur="0.5s" begin="1.2s" fill="freeze" />
        </rect>
        <circle cx="100" cy="100" r="15" fill="#ffff00">
          <animate attributeName="r" from="0" to="15" dur="0.5s" begin="1.5s" fill="freeze" />
        </circle>
      </svg>
    </div>
    <div class="loading-bar-container">
      <div class="loading-bar" id="loadingBar"></div>
    </div>
    <div class="loading-text" id="loadingText">Loading Game Assets...</div>
  </div>

  <!-- Main Game Container -->
  <div class="game-container">
    <!-- 3D Game Canvas -->
    <canvas id="gameCanvas"></canvas>
    
    <!-- UI Layer -->
    <div class="ui-container">
      <!-- Score display -->
      <div class="score-container">
        <div id="scores">
          <div class="player-score left">0</div>
          <div class="player-score right">0</div>
        </div>
      </div>
      
      <!-- Power-up displays -->
      <div class="power-up-display left" id="leftPowerUps"></div>
      <div class="power-up-display right" id="rightPowerUps"></div>
      
      <!-- Game mode panel -->
      <div id="gameModePanel" class="ui-panel" style="display:none;">
        <div class="panel-header">
          <h2 class="panel-title">Game Mode</h2>
          <button class="cyber-button" onclick="togglePanel('gameModePanel')" style="min-width: auto; padding: 5px 10px;">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="panel-content">
          <div class="btn-group" id="gameModeButtons">
            <button id="ai-vs-ai" class="cyber-button active" onclick="setGameMode('ai-vs-ai')">AI vs AI</button>
            <button id="human-vs-ai" class="cyber-button" onclick="setGameMode('human-vs-ai')">Human vs AI</button>
            <button id="ai-vs-human" class="cyber-button" onclick="setGameMode('ai-vs-human')">AI vs Human</button>
            <button id="human-vs-human" class="cyber-button" onclick="setGameMode('human-vs-human')">Local 2 Player</button>
            <button id="multiplayer" class="cyber-button secondary" onclick="setGameMode('multiplayer')">Online Multiplayer</button>
          </div>
        </div>
      </div>
      
      <!-- Mobile controls (only shown on mobile) -->
      <div class="mobile-controls" id="mobileControls" style="display:none;">
        <div class="mobile-control left-up" id="leftPaddleUp">
          <i class="fas fa-chevron-up"></i>
        </div>
        <div class="mobile-control left-down" id="leftPaddleDown">
          <i class="fas fa-chevron-down"></i>
        </div>
        <div class="mobile-control right-up" id="rightPaddleUp">
          <i class="fas fa-chevron-up"></i>
        </div>
        <div class="mobile-control right-down" id="rightPaddleDown">
          <i class="fas fa-chevron-down"></i>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Main Menu -->
  <div id="mainMenu" class="ui-panel">
    <div class="panel-header">
      <h2 class="panel-title">3D COSMIC PONG ARENA</h2>
    </div>
    <div class="panel-content">
      <div class="btn-group">
        <button class="cyber-button" onclick="startGame()">PLAY GAME</button>
        <button class="cyber-button" onclick="showPanel('settingsPanel')">SETTINGS</button>
        <button class="cyber-button secondary" onclick="showPanel('multiplayerPanel')">MULTIPLAYER</button>
        <button class="cyber-button secondary" onclick="showPanel('storePanel')">STORE</button>
        <button class="cyber-button warning" onclick="showPanel('howToPlayPanel')">HOW TO PLAY</button>
      </div>
      
      <div class="controls-help">
        <h4>Controls:</h4>
        <p>Left Paddle: <span class="key">W</span> (up) and <span class="key">S</span> (down)</p>
        <p>Right Paddle: <span class="key">↑</span> (up) and <span class="key">↓</span> (down)</p>
        <p>Pause Game: <span class="key">ESC</span> or <span class="key">P</span></p>
      </div>
    </div>
  </div>
  
  <!-- Settings Panel -->
  <div id="settingsPanel" class="ui-panel" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:800px; max-height:80vh;">
    <div class="panel-header">
      <h2 class="panel-title">Game Settings</h2>
      <button class="cyber-button" onclick="hidePanel('settingsPanel')" style="min-width: auto; padding: 5px 10px;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="panel-content">
      <div class="settings-section">
        <h3>Game Settings</h3>
        <div class="settings-grid">
          <div class="cyber-slider">
            <label for="gameSpeed">Game Speed</label>
            <div class="slider-container">
              <input type="range" min="0.5" max="5" step="0.1" value="2.2" class="slider" id="gameSpeed">
            </div>
            <div class="slider-value" id="gameSpeedValue">2.2</div>
          </div>
          
          <div class="cyber-slider">
            <label for="baseBallSpeed">Ball Speed</label>
            <div class="slider-container">
              <input type="range" min="1" max="10" step="0.1" value="4" class="slider" id="baseBallSpeed">
            </div>
            <div class="slider-value" id="baseBallSpeedValue">4</div>
          </div>
          
          <div class="cyber-slider">
            <label for="maxPoints">Max Points</label>
            <div class="slider-container">
              <input type="range" min="1" max="20" step="1" value="10" class="slider" id="maxPoints">
            </div>
            <div class="slider-value" id="maxPointsValue">10</div>
          </div>
          
          <div class="cyber-slider">
            <label for="powerUpFrequency">Power-Up Frequency</label>
            <div class="slider-container">
              <input type="range" min="1000" max="10000" step="500" value="5000" class="slider" id="powerUpFrequency">
            </div>
            <div class="slider-value" id="powerUpFrequencyValue">5s</div>
          </div>
          
          <div class="cyber-slider">
            <label for="extraSpeedFactor">Rally Speed Factor</label>
            <div class="slider-container">
              <input type="range" min="0.01" max="0.2" step="0.01" value="0.05" class="slider" id="extraSpeedFactor">
            </div>
            <div class="slider-value" id="extraSpeedFactorValue">0.05</div>
          </div>
          
          <div class="cyber-slider">
            <label for="randomnessLevel">Randomness</label>
            <div class="slider-container">
              <input type="range" min="1" max="30" step="1" value="15" class="slider" id="randomnessLevel">
            </div>
            <div class="slider-value" id="randomnessLevelValue">15</div>
          </div>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>AI Difficulty</h3>
        <div class="settings-grid">
          <div class="settings-row">
            <label for="leftDifficulty">Left AI</label>
            <select id="leftDifficulty">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
              <option value="insane">Insane</option>
              <option value="adaptive">Adaptive</option>
            </select>
          </div>
          
          <div class="settings-row">
            <label for="rightDifficulty">Right AI</label>
            <select id="rightDifficulty">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
              <option value="insane">Insane</option>
              <option value="adaptive">Adaptive</option>
            </select>
          </div>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Graphics Settings</h3>
        <div class="settings-grid">
          <div class="cyber-slider">
            <label for="graphicsQuality">Quality</label>
            <div class="slider-container">
              <input type="range" min="0" max="2" step="1" value="1" class="slider" id="graphicsQuality">
            </div>
            <div class="slider-value" id="graphicsQualityValue">Medium</div>
          </div>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="enableParticles" checked>
            <span class="checkmark"></span>
            Particle Effects
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="enableBloom" checked>
            <span class="checkmark"></span>
            Bloom Effects
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="enableShadows" checked>
            <span class="checkmark"></span>
            Shadows
          </label>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Sound Settings</h3>
        <div class="settings-grid">
          <div class="cyber-slider">
            <label for="masterVolume">Master Volume</label>
            <div class="slider-container">
              <input type="range" min="0" max="1" step="0.01" value="0.8" class="slider" id="masterVolume">
            </div>
            <div class="slider-value" id="masterVolumeValue">80%</div>
          </div>
          
          <div class="cyber-slider">
            <label for="sfxVolume">SFX Volume</label>
            <div class="slider-container">
              <input type="range" min="0" max="1" step="0.01" value="0.8" class="slider" id="sfxVolume">
            </div>
            <div class="slider-value" id="sfxVolumeValue">80%</div>
          </div>
          
          <div class="cyber-slider">
            <label for="musicVolume">Music Volume</label>
            <div class="slider-container">
              <input type="range" min="0" max="1" step="0.01" value="0.5" class="slider" id="musicVolume">
            </div>
            <div class="slider-value" id="musicVolumeValue">50%</div>
          </div>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="enableMusic" checked>
            <span class="checkmark"></span>
            Background Music
          </label>
        </div>
      </div>
      
      <div class="btn-group">
        <button class="cyber-button" onclick="applySettings()">Apply Settings</button>
        <button class="cyber-button warning" onclick="resetSettings()">Reset Defaults</button>
      </div>
    </div>
  </div>
  
  <!-- Power-Up Settings Panel -->
  <div id="powerUpPanel" class="ui-panel" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:800px; max-height:80vh;">
    <div class="panel-header">
      <h2 class="panel-title">Power-Up Settings</h2>
      <button class="cyber-button" onclick="hidePanel('powerUpPanel')" style="min-width: auto; padding: 5px 10px;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="panel-content">
      <div class="settings-section">
        <h3>Enable/Disable Power-Ups</h3>
        <div class="settings-grid">
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleSpeed" checked>
            <span class="checkmark" style="border-color: #ffeb3b;"></span>
            Paddle Accelerator
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleBallSpeed" checked>
            <span class="checkmark" style="border-color: #f44336;"></span>
            Ball Blaster
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleShrink" checked>
            <span class="checkmark" style="border-color: #800080;"></span>
            Paddle Shrinker
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleShield" checked>
            <span class="checkmark" style="border-color: #2196F3;"></span>
            Shield
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleMagnet" checked>
            <span class="checkmark" style="border-color: #4CAF50;"></span>
            Magnet
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleGiant" checked>
            <span class="checkmark" style="border-color: #FF9800;"></span>
            Giant Paddle
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleGhost" checked>
            <span class="checkmark" style="border-color: #FFFFFF;"></span>
            Ghost Ball
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleMultiBall" checked>
            <span class="checkmark" style="border-color: #00FFFF;"></span>
            Multi-Ball
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleFreeze" checked>
            <span class="checkmark" style="border-color: #008080;"></span>
            Freeze Opponent
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleGravity" checked>
            <span class="checkmark" style="border-color: #8000FF;"></span>
            Gravity Well
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleTimeSlow" checked>
            <span class="checkmark" style="border-color: #00FF00;"></span>
            Time Warp
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleTeleport" checked>
            <span class="checkmark" style="border-color: #FF00FF;"></span>
            Ball Portal
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleSuperShot" checked>
            <span class="checkmark" style="border-color: #FF3300;"></span>
            Super Shot
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleMirror" checked>
            <span class="checkmark" style="border-color: #AAAAAA;"></span>
            Mirror Dimension
          </label>
          
          <label class="cyber-checkbox">
            <input type="checkbox" id="toggleObstacle" checked>
            <span class="checkmark" style="border-color: #663300;"></span>
            Obstacle
          </label>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Power-Up Chances</h3>
        <div class="settings-grid">
          <div class="cyber-slider">
            <label for="speedChance">Speed Chance</label>
            <div class="slider-container">
              <input type="range" min="0" max="100" step="1" value="10" class="slider" id="speedChance">
            </div>
            <div class="slider-value" id="speedChanceValue">10%</div>
          </div>
          
          <div class="cyber-slider">
            <label for="ballSpeedChance">Ball Speed</label>
            <div class="slider-container">
              <input type="range" min="0" max="100" step="1" value="10" class="slider" id="ballSpeedChance">
            </div>
            <div class="slider-value" id="ballSpeedChanceValue">10%</div>
          </div>
          
          <!-- Add all other power-up chance sliders here -->
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Power-Up Duration</h3>
        <div class="settings-grid">
          <div class="cyber-slider">
            <label for="powerUpDurationFactor">Duration Multiplier</label>
            <div class="slider-container">
              <input type="range" min="0.5" max="2" step="0.1" value="1" class="slider" id="powerUpDurationFactor">
            </div>
            <div class="slider-value" id="powerUpDurationFactorValue">1.0x</div>
          </div>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Power-Up Strength</h3>
        <div class="settings-grid">
          <div class="cyber-slider">
            <label for="powerUpStrengthFactor">Strength Multiplier</label>
            <div class="slider-container">
              <input type="range" min="0.5" max="2" step="0.1" value="1" class="slider" id="powerUpStrengthFactor">
            </div>
            <div class="slider-value" id="powerUpStrengthFactorValue">1.0x</div>
          </div>
        </div>
      </div>
      
      <div class="btn-group">
        <button class="cyber-button" onclick="applyPowerUpSettings()">Apply Settings</button>
        <button class="cyber-button warning" onclick="resetPowerUpSettings()">Reset Defaults</button>
      </div>
    </div>
  </div>
  
  <!-- Multiplayer Panel -->
  <div id="multiplayerPanel" class="ui-panel" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:800px; max-height:80vh;">
    <div class="panel-header">
      <h2 class="panel-title">Multiplayer</h2>
      <button class="cyber-button" onclick="hidePanel('multiplayerPanel')" style="min-width: auto; padding: 5px 10px;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="panel-content">
      <div class="settings-section">
        <h3>Player Profile</h3>
        <div class="settings-row">
          <label for="playerName">Player Name:</label>
          <input type="text" id="playerName" value="Player" style="width: 200px;">
        </div>
        
        <div class="settings-row">
          <label for="playerAvatar">Avatar Color:</label>
          <select id="playerAvatar">
            <option value="cyan">Cyan</option>
            <option value="magenta">Magenta</option>
            <option value="yellow">Yellow</option>
            <option value="green">Green</option>
            <option value="red">Red</option>
            <option value="blue">Blue</option>
          </select>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Online Players</h3>
        <div class="player-list" id="onlinePlayers">
          <div class="player-item">
            <div class="player-avatar" style="background:var(--primary);">P</div>
            <div class="player-info">
              <div class="player-name">PlayerOne</div>
              <div class="player-status">Online - Waiting for match</div>
            </div>
            <div class="player-stats">
              <div class="player-stat"><i class="fas fa-trophy"></i> 15</div>
              <div class="player-stat"><i class="fas fa-gamepad"></i> 42</div>
            </div>
            <button class="cyber-button" style="min-width: auto; padding: 8px 15px;">Challenge</button>
          </div>
          
          <div class="player-item">
            <div class="player-avatar" style="background:var(--secondary);">G</div>
            <div class="player-info">
              <div class="player-name">GamerXYZ</div>
              <div class="player-status">In Game</div>
            </div>
            <div class="player-stats">
              <div class="player-stat"><i class="fas fa-trophy"></i> 28</div>
              <div class="player-stat"><i class="fas fa-gamepad"></i> 65</div>
            </div>
            <button class="cyber-button" style="min-width: auto; padding: 8px 15px;" disabled>Challenge</button>
          </div>
        </div>
      </div>
      
      <div class="btn-group">
        <button class="cyber-button secondary" onclick="findMatch()">Quick Match</button>
        <button class="cyber-button secondary" onclick="hostPrivateGame()">Host Private Game</button>
        <button class="cyber-button secondary" onclick="joinPrivateGame()">Join Private Game</button>
      </div>
    </div>
  </div>
  
  <!-- Store Panel -->
  <div id="storePanel" class="ui-panel" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:800px; max-height:80vh;">
    <div class="panel-header">
      <h2 class="panel-title">Cosmic Pong Store</h2>
      <button class="cyber-button" onclick="hidePanel('storePanel')" style="min-width: auto; padding: 5px 10px;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="panel-content">
      <div class="settings-section">
        <h3>Your Credits: <span id="playerCredits">1000</span> <i class="fas fa-gem" style="color:var(--tertiary);"></i></h3>
        
        <div class="store-grid">
          <div class="store-item">
            <div class="store-item-image">
              <i class="fas fa-palette" style="font-size: 48px; color: var(--tertiary);"></i>
            </div>
            <h3 class="store-item-title">Neon Paddle Pack</h3>
            <p class="store-item-description">Customize your paddle with glowing neon colors and effects.</p>
            <div class="store-item-price"><i class="fas fa-gem" class="currency-icon"></i> 200</div>
            <button class="cyber-button" onclick="purchaseItem('neon_paddle_pack')">Purchase</button>
          </div>
          
          <div class="store-item">
            <div class="store-item-image">
              <i class="fas fa-meteor" style="font-size: 48px; color: var(--secondary);"></i>
            </div>
            <h3 class="store-item-title">Cosmic Ball Skins</h3>
            <p class="store-item-description">Transform your ball into a miniature planet, star, or asteroid.</p>
            <div class="store-item-price"><i class="fas fa-gem" class="currency-icon"></i> 300</div>
            <button class="cyber-button" onclick="purchaseItem('cosmic_ball_skins')">Purchase</button>
          </div>
          
          <div class="store-item">
            <div class="store-item-image">
              <i class="fas fa-magic" style="font-size: 48px; color: var(--primary);"></i>
            </div>
            <h3 class="store-item-title">Premium Power-Ups</h3>
            <p class="store-item-description">Unlock 5 exclusive power-ups only available to premium players.</p>
            <div class="store-item-price"><i class="fas fa-gem" class="currency-icon"></i> 500</div>
            <button class="cyber-button" onclick="purchaseItem('premium_powerups')">Purchase</button>
          </div>
          
          <div class="store-item">
            <div class="store-item-image">
              <i class="fas fa-vr-cardboard" style="font-size: 48px; color: #FF9800;"></i>
            </div>
            <h3 class="store-item-title">Arena Themes</h3>
            <p class="store-item-description">Play in new environments: Space Station, Cyberpunk City, and more.</p>
            <div class="store-item-price"><i class="fas fa-gem" class="currency-icon"></i> 450</div>
            <button class="cyber-button" onclick="purchaseItem('arena_themes')">Purchase</button>
          </div>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Credits Packs</h3>
        <div class="store-grid">
          <div class="store-item">
            <div class="store-item-image">
              <i class="fas fa-gem" style="font-size: 48px; color: var(--tertiary);"></i>
            </div>
            <h3 class="store-item-title">500 Credits</h3>
            <p class="store-item-description">Get 500 credits to spend on customizations and power-ups.</p>
            <div class="store-item-price">$4.99 USD</div>
            <div id="paypal-500-container"></div>
          </div>
          
          <div class="store-item">
            <div class="store-item-image">
              <i class="fas fa-gem" style="font-size: 48px; color: var(--tertiary);"></i>
              <i class="fas fa-gem" style="font-size: 48px; color: var(--tertiary); margin-left: -20px;"></i>
            </div>
            <h3 class="store-item-title">1200 Credits</h3>
            <p class="store-item-description">Get 1200 credits (20% bonus) to spend in the store.</p>
            <div class="store-item-price">$9.99 USD</div>
            <div id="paypal-1200-container"></div>
          </div>
          
          <div class="store-item">
            <div class="store-item-image">
              <i class="fas fa-gem" style="font-size: 48px; color: var(--tertiary);"></i>
              <i class="fas fa-gem" style="font-size: 48px; color: var(--tertiary); margin-left: -20px;"></i>
              <i class="fas fa-gem" style="font-size: 48px; color: var(--tertiary); margin-left: -20px;"></i>
            </div>
            <h3 class="store-item-title">3000 Credits</h3>
            <p class="store-item-description">Get 3000 credits (50% bonus) to spend in the store.</p>
            <div class="store-item-price">$19.99 USD</div>
            <div id="paypal-3000-container"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  
  <!-- How To Play Panel -->
  <div id="howToPlayPanel" class="ui-panel" style="display:none; position:absolute; top:50%; left:50%; transform:translate(-50%, -50%); width:800px; max-height:80vh;">
    <div class="panel-header">
      <h2 class="panel-title">How To Play</h2>
      <button class="cyber-button" onclick="hidePanel('howToPlayPanel')" style="min-width: auto; padding: 5px 10px;">
        <i class="fas fa-times"></i>
      </button>
    </div>
    <div class="panel-content">
      <div class="settings-section">
        <h3>Basic Controls</h3>
        <p>Move your paddle to hit the ball and prevent it from passing your side of the arena.</p>
        <div class="controls-help">
          <p>Left Paddle: <span class="key">W</span> (up) and <span class="key">S</span> (down)</p>
          <p>Right Paddle: <span class="key">↑</span> (up) and <span class="key">↓</span> (down)</p>
          <p>Pause Game: <span class="key">ESC</span> or <span class="key">P</span></p>
        </div>
      </div>
      
      <div class="settings-section">
        <h3>Power-Ups</h3>
        <p>Collect power-ups that appear in the arena to gain advantages or hinder your opponent:</p>
        <ul style="list-style-type: none; padding: 0;">
          <li><i class="fas fa-bolt" style="color: #ffeb3b; margin-right: 10px;"></i> <strong>Paddle Accelerator:</strong> Increases your paddle's movement speed</li>
          <li><i class="fas fa-fire" style="color: #f44336; margin-right: 10px;"></i> <strong>Ball Blaster:</strong> Increases the ball speed when it's on your opponent's side</li>
          <li><i class="fas fa-compress-arrows-alt" style="color: #800080; margin-right: 10px;"></i> <strong>Paddle Shrinker:</strong> Shrinks your opponent's paddle</li>
          <li><i class="fas fa-shield-alt" style="color: #2196F3; margin-right: 10px;"></i> <strong>Shield:</strong> Protects your goal once</li>
          <li><i class="fas fa-magnet" style="color: #4CAF50; margin-right: 10px;"></i> <strong>Magnet:</strong> Attracts the ball slightly toward your paddle</li>
          <li><i class="fas fa-expand-arrows-alt" style="color: #FF9800; margin-right: 10px;"></i> <strong>Giant Paddle:</strong> Increases your paddle size</li>
          <li><i class="fas fa-ghost" style="color: #FFFFFF; margin-right: 10px;"></i> <strong>Ghost Ball:</strong> Makes the ball semi-transparent and harder to track</li>
          <li><i class="fas fa-clone" style="color: #00FFFF; margin-right: 10px;"></i> <strong>Multi-Ball:</strong> Adds an extra ball to the game</li>
          <li><i class="fas fa-snowflake" style="color: #008080; margin-right: 10px;"></i> <strong>Freeze:</strong> Temporarily freezes your opponent's paddle</li>
          <li><i class="fas fa-atom" style="color: #8000FF; margin-right: 10px;"></i> <strong>Gravity Well:</strong> Creates a gravity field that affects ball trajectory</li>
        </ul>
      </div>
      
      <div class="settings-section">
        <h3>Game Modes</h3>
        <p><strong>AI vs AI:</strong> Watch two AI players compete against each other</p>
        <p><strong>Human vs AI:</strong> Play against the computer</p>
        <p><strong>Human vs Human:</strong> Play against a friend on the same device</p>
        <p><strong>Online Multiplayer:</strong> Challenge players from around the world</p>
      </div>
    </div>
  </div>
  
  <!-- Notification Container -->
  <div class="notification-container" id="notificationContainer"></div>

  <script>
    // 3D Game Engine with Three.js
    let scene, camera, renderer, gameScene;
    let leftPaddle, rightPaddle, ball, gameField, particles;
    let leftScore = 0, rightScore = 0;
    let powerUps = [];
    let powerUpTimer = 0;
    let multiBalls = [];
    let gravityWells = [];
    
    // Game state
    let gameState = 'menu'; // menu, playing, paused, gameOver, finished
    let currentGameMode = 'ai-vs-ai';
    let isMultiplayer = false;
    let socket = null;
    
    // Player setup
    let playerName = 'Player';
    let playerAvatar = 'cyan';
    let playerCredits = 1000;
    let playerItems = {};
    
    // Settings and configuration
    let settings = {
      game: {
        gameSpeed: 2.2,
        baseBallSpeed: 4,
        maxPoints: 10,
        powerUpFrequency: 5000,
        extraSpeedFactor: 0.05,
        randomnessLevel: 15
      },
      ai: {
        leftDifficulty: 'normal',
        rightDifficulty: 'normal'
      },
      graphics: {
        quality: 1, // 0: low, 1: medium, 2: high
        enableParticles: true,
        enableBloom: true,
        enableShadows: true
      },
      sound: {
        masterVolume: 0.8,
        sfxVolume: 0.8,
        musicVolume: 0.5,
        enableMusic: true
      },
      powerUps: {
        durationFactor: 1.0,
        strengthFactor: 1.0,
        enabled: {
          speed: true,
          ballSpeed: true,
          shrink: true,
          shield: true,
          magnet: true,
          giant: true,
          ghost: true,
          multiBall: true,
          freeze: true,
          gravity: true,
          timeSlow: true,
          teleport: true,
          superShot: true,
          mirror: true,
          obstacle: true
        },
        chances: {
          speed: 10,
          ballSpeed: 10,
          shrink: 10,
          shield: 10,
          magnet: 10,
          giant: 10,
          ghost: 10,
          multiBall: 10,
          freeze: 10,
          gravity: 10,
          timeSlow: 10,
          teleport: 10,
          superShot: 10,
          mirror: 10,
          obstacle: 10
        }
      }
    };
    
    // Paddle properties
    const PADDLE_WIDTH = 1;
    const PADDLE_HEIGHT = 10;
    const PADDLE_DEPTH = 3;
    const PADDLE_SPEED = 0.5;
    
    // Ball properties
    const BALL_RADIUS = 1;
    const BALL_SEGMENTS = 32;
    
    // Game field dimensions
    const FIELD_WIDTH = 80;
    const FIELD_HEIGHT = 50;
    const FIELD_DEPTH = 5;
    
    // Sound effects
    const sounds = {
      paddle: new Howl({ src: ['https://assets.codepen.io/21542/impactPlank_medium_004.mp3'], volume: 0.7 }),
      wall: new Howl({ src: ['https://assets.codepen.io/21542/impactGlass_medium_004.mp3'], volume: 0.5 }),
      score: new Howl({ src: ['https://assets.codepen.io/21542/jingles_PIZZI10.mp3'], volume: 0.8 }),
      powerUp: new Howl({ src: ['https://assets.codepen.io/21542/powerUp12.mp3'], volume: 0.6 }),
      music: new Howl({ 
        src: ['https://assets.codepen.io/21542/Cyberpunk-Streetlight-Serenade.mp3'], 
        volume: 0.3, 
        loop: true 
      })
    };
    
    // Mobile detection
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    
    // Initialize loading sequence
    document.addEventListener('DOMContentLoaded', initLoading);
    
    function initLoading() {
      // Update loading bar as assets are loaded
      const loadingBar = document.getElementById('loadingBar');
      const loadingText = document.getElementById('loadingText');
      
      let progress = 0;
      const interval = setInterval(() => {
        progress += 5;
        loadingBar.style.width = `${progress}%`;
        
        if (progress === 30) {
          loadingText.textContent = 'Initializing 3D Engine...';
        } else if (progress === 50) {
          loadingText.textContent = 'Loading Game Assets...';
        } else if (progress === 80) {
          loadingText.textContent = 'Preparing Cosmic Arena...';
        } else if (progress >= 100) {
          clearInterval(interval);
          loadingText.textContent = 'Ready to Play!';
          
          // Fade out loading screen
          setTimeout(() => {
            document.getElementById('loadingScreen').style.opacity = '0';
            setTimeout(() => {
              document.getElementById('loadingScreen').style.display = 'none';
              initGame();
            }, 1000);
          }, 500);
        }
      }, 80);
      
      // Initialize PayPal buttons
      initPayPalButtons();
      
      // Set up event listeners for slider values
      setupSliderListeners();
    }
    
    function setupSliderListeners() {
      const sliders = document.querySelectorAll('.slider');
      sliders.forEach(slider => {
        const valueDisplay = document.getElementById(`${slider.id}Value`);
        if (valueDisplay) {
          valueDisplay.textContent = slider.value;
          
          // Display special formatting for certain types
          if (slider.id === 'masterVolume' || slider.id === 'sfxVolume' || slider.id === 'musicVolume') {
            valueDisplay.textContent = `${Math.round(slider.value * 100)}%`;
          } else if (slider.id === 'powerUpFrequency') {
            valueDisplay.textContent = `${slider.value / 1000}s`;
          } else if (slider.id === 'graphicsQuality') {
            const qualities = ['Low', 'Medium', 'High'];
            valueDisplay.textContent = qualities[parseInt(slider.value)];
          } else if (slider.id === 'powerUpDurationFactor' || slider.id === 'powerUpStrengthFactor') {
            valueDisplay.textContent = `${slider.value}x`;
          } else if (slider.id.includes('Chance')) {
            valueDisplay.textContent = `${slider.value}%`;
          }
          
          slider.addEventListener('input', () => {
            if (slider.id === 'masterVolume' || slider.id === 'sfxVolume' || slider.id === 'musicVolume') {
              valueDisplay.textContent = `${Math.round(slider.value * 100)}%`;
            } else if (slider.id === 'powerUpFrequency') {
              valueDisplay.textContent = `${slider.value / 1000}s`;
            } else if (slider.id === 'graphicsQuality') {
              const qualities = ['Low', 'Medium', 'High'];
              valueDisplay.textContent = qualities[parseInt(slider.value)];
            } else if (slider.id === 'powerUpDurationFactor' || slider.id === 'powerUpStrengthFactor') {
              valueDisplay.textContent = `${slider.value}x`;
            } else if (slider.id.includes('Chance')) {
              valueDisplay.textContent = `${slider.value}%`;
            } else {
              valueDisplay.textContent = slider.value;
            }
          });
        }
      });
    }
    
    function initPayPalButtons() {
      // Initialize PayPal buttons for each credit pack
      const paypal500Button = paypal.Buttons({
        createOrder: function(data, actions) {
          return actions.order.create({
            purchase_units: [{
              amount: {
                value: '4.99'
              },
              description: '500 Credits for Cosmic Pong'
            }]
          });
        },
        onApprove: function(data, actions) {
          return actions.order.capture().then(function(details) {
            addCredits(500);
            showNotification('Payment Successful', `Thank you, ${details.payer.name.given_name}! 500 credits have been added to your account.`, 'success');
          });
        },
        style: {
          layout: 'horizontal',
          color: 'blue',
          shape: 'rect',
          label: 'pay',
          height: 40
        }
      });
      
      const paypal1200Button = paypal.Buttons({
        createOrder: function(data, actions) {
          return actions.order.create({
            purchase_units: [{
              amount: {
                value: '9.99'
              },
              description: '1200 Credits for Cosmic Pong'
            }]
          });
        },
        onApprove: function(data, actions) {
          return actions.order.capture().then(function(details) {
            addCredits(1200);
            showNotification('Payment Successful', `Thank you, ${details.payer.name.given_name}! 1200 credits have been added to your account.`, 'success');
          });
        },
        style: {
          layout: 'horizontal',
          color: 'blue',
          shape: 'rect',
          label: 'pay',
          height: 40
        }
      });
      
      const paypal3000Button = paypal.Buttons({
        createOrder: function(data, actions) {
          return actions.order.create({
            purchase_units: [{
              amount: {
                value: '19.99'
              },
              description: '3000 Credits for Cosmic Pong'
            }]
          });
        },
        onApprove: function(data, actions) {
          return actions.order.capture().then(function(details) {
            addCredits(3000);
            showNotification('Payment Successful', `Thank you, ${details.payer.name.given_name}! 3000 credits have been added to your account.`, 'success');
          });
        },
        style: {
          layout: 'horizontal',
          color: 'blue',
          shape: 'rect',
          label: 'pay',
          height: 40
        }
      });
      
      // Render the PayPal buttons
      paypal500Button.render('#paypal-500-container');
      paypal1200Button.render('#paypal-1200-container');
      paypal3000Button.render('#paypal-3000-container');
    }
    
    function initGame() {
      // Load stored settings if available
      loadSettings();
      
      // Display main menu
      document.getElementById('mainMenu').style.display = 'block';
      
      // Initialize the game renderer and scene
      initRenderer();
      
      // Enter the animation loop
      animate();
    }
    
    function initRenderer() {
      // Create Three.js scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000033);
      scene.fog = new THREE.FogExp2(0x000033, 0.01);
      
      // Create camera
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
      camera.position.z = 60;
      camera.position.y = 20;
      camera.lookAt(0, 0, 0);
      
      // Create renderer
      renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.shadowMap.enabled = settings.graphics.enableShadows;
      
      // Handle window resize
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      // Create game scene group
      gameScene = new THREE.Group();
      scene.add(gameScene);
      
      // Create ambient light
      const ambientLight = new THREE.AmbientLight(0x333344, 0.5);
      scene.add(ambientLight);
      
      // Create directional light
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(20, 30, 50);
      directionalLight.castShadow = settings.graphics.enableShadows;
      scene.add(directionalLight);
      
      // Add point lights for glow effect
      const pointLight1 = new THREE.PointLight(0x00ffff, 1, 100);
      pointLight1.position.set(-30, 10, 20);
      scene.add(pointLight1);
      
      const pointLight2 = new THREE.PointLight(0xff00ff, 1, 100);
      pointLight2.position.set(30, 10, 20);
      scene.add(pointLight2);
      
      // Create the starfield background
      createStarfield();
      
      // Create the game field
      createGameField();
      
      // Create paddles
      createPaddles();
      
      // Create the ball
      createBall();
      
      // Position game scene
      gameScene.position.y = -10;
    }
    
    function createStarfield() {
      // Create star particles
      const starGeometry = new THREE.BufferGeometry();
      const starMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.2,
        transparent: true,
        opacity: 0.8,
        map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png'),
        blending: THREE.AdditiveBlending
      });
      
      // Generate random stars
      const starPositions = [];
      const starCount = 2000;
      const starSpread = 300;
      
      for (let i = 0; i < starCount; i++) {
        const x = THREE.MathUtils.randFloatSpread(starSpread);
        const y = THREE.MathUtils.randFloatSpread(starSpread);
        const z = THREE.MathUtils.randFloatSpread(starSpread) - 100; // Move stars behind the game
        
        starPositions.push(x, y, z);
      }
      
      starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starPositions, 3));
      const stars = new THREE.Points(starGeometry, starMaterial);
      scene.add(stars);
    }
    
    function createGameField() {
      // Create game field
      const fieldGeometry = new THREE.BoxGeometry(FIELD_WIDTH, FIELD_HEIGHT, FIELD_DEPTH);
      
      // Create glowing wireframe material
      const edgesMaterial = new THREE.LineBasicMaterial({ 
        color: 0x00fcff,
        transparent: true,
        opacity: 0.3
      });
      
      // Create edges geometry
      const edges = new THREE.EdgesGeometry(fieldGeometry);
      const wireframe = new THREE.LineSegments(edges, edgesMaterial);
      gameScene.add(wireframe);
      gameField = wireframe;
      
      // Create center line
      const centerLineGeometry = new THREE.PlaneGeometry(0.3, FIELD_HEIGHT, 1, 10);
      const centerLineMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00fcff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      
      const centerLine = new THREE.Mesh(centerLineGeometry, centerLineMaterial);
      centerLine.rotation.y = Math.PI / 2;
      gameScene.add(centerLine);
      
      // Create center circle
      const centerCircleGeometry = new THREE.RingGeometry(7, 7.3, 32);
      const centerCircleMaterial = new THREE.MeshBasicMaterial({ 
        color: 0x00fcff,
        transparent: true,
        opacity: 0.3,
        side: THREE.DoubleSide
      });
      
      const centerCircle = new THREE.Mesh(centerCircleGeometry, centerCircleMaterial);
      centerCircle.rotation.x = Math.PI / 2;
      gameScene.add(centerCircle);
      
      // Create floor with grid texture
      const floorGeometry = new THREE.PlaneGeometry(FIELD_WIDTH, FIELD_HEIGHT);
      const floorMaterial = new THREE.MeshBasicMaterial({
        color: 0x000066,
        transparent: true,
        opacity: 0.2,
        side: THREE.DoubleSide
      });
      
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = Math.PI / 2;
      floor.position.y = -FIELD_DEPTH / 2;
      gameScene.add(floor);
      
      // Create grid lines on floor
      const gridHelper = new THREE.GridHelper(FIELD_WIDTH, 20, 0x00fcff, 0x00fcff);
      gridHelper.position.y = -FIELD_DEPTH / 2 + 0.01;
      gridHelper.material.transparent = true;
      gridHelper.material.opacity = 0.1;
      gameScene.add(gridHelper);
    }
    
    function createPaddles() {
      // Create paddle geometry
      const paddleGeometry = new THREE.BoxGeometry(PADDLE_WIDTH, PADDLE_HEIGHT, PADDLE_DEPTH);
      
      // Create left paddle with glow effect
      const leftPaddleMaterial = new THREE.MeshPhongMaterial({ 
        color: 0x00fcff,
        emissive: 0x00fcff,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.9,
        shininess: 50
      });
      
      leftPaddle = new THREE.Mesh(paddleGeometry, leftPaddleMaterial);
      leftPaddle.position.set(-FIELD_WIDTH / 2 + 3, 0, 0);
      leftPaddle.castShadow = settings.graphics.enableShadows;
      leftPaddle.receiveShadow = settings.graphics.enableShadows;
      leftPaddle.userData = {
        speed: PADDLE_SPEED,
        direction: 0,
        score: 0,
        height: PADDLE_HEIGHT,
        isAI: true,
        difficulty: settings.ai.leftDifficulty,
        activePowerUps: [],
        isFrozen: false,
        frozenUntil: 0
      };
      gameScene.add(leftPaddle);
      
      // Create right paddle with glow effect
      const rightPaddleMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xff00ff,
        emissive: 0xff00ff,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.9,
        shininess: 50
      });
      
      rightPaddle = new THREE.Mesh(paddleGeometry, rightPaddleMaterial);
      rightPaddle.position.set(FIELD_WIDTH / 2 - 3, 0, 0);
      rightPaddle.castShadow = settings.graphics.enableShadows;
      rightPaddle.receiveShadow = settings.graphics.enableShadows;
      rightPaddle.userData = {
        speed: PADDLE_SPEED,
        direction: 0,
        score: 0,
        height: PADDLE_HEIGHT,
        isAI: true,
        difficulty: settings.ai.rightDifficulty,
        activePowerUps: [],
        isFrozen: false,
        frozenUntil: 0
      };
      gameScene.add(rightPaddle);
    }
    
    function createBall() {
      // Create ball geometry
      const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, BALL_SEGMENTS, BALL_SEGMENTS);
      
      // Create ball material with glow effect
      const ballMaterial = new THREE.MeshPhongMaterial({ 
        color: 0xffffff,
        emissive: 0xffffaa,
        emissiveIntensity: 0.5,
        transparent: true,
        opacity: 0.9,
        shininess: 80
      });
      
      ball = new THREE.Mesh(ballGeometry, ballMaterial);
      ball.castShadow = settings.graphics.enableShadows;
      ball.receiveShadow = settings.graphics.enableShadows;
      ball.userData = {
        velocity: new THREE.Vector3(settings.game.baseBallSpeed, 0, 0),
        baseSpeed: settings.game.baseBallSpeed,
        speed: settings.game.baseBallSpeed,
        isGhost: false,
        ghostOpacity: 1
      };
      gameScene.add(ball);
      
      // Reset ball position
      resetBall();
      
      // Create ball trail if particles are enabled
      if (settings.graphics.enableParticles) {
        createBallTrail();
      }
    }
    
    function createBallTrail() {
      // Create particle system for the ball trail
      const particleCount = 100;
      const particleGeometry = new THREE.BufferGeometry();
      const particleMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        transparent: true,
        opacity: 0.6,
        map: new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png'),
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      
      // Create particle positions
      const positions = new Float32Array(particleCount * 3);
      const alphas = new Float32Array(particleCount);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = ball.position.x;
        positions[i * 3 + 1] = ball.position.y;
        positions[i * 3 + 2] = ball.position.z;
        alphas[i] = 0;
      }
      
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('alpha', new THREE.BufferAttribute(alphas, 1));
      
      particles = new THREE.Points(particleGeometry, particleMaterial);
      gameScene.add(particles);
    }
    
    function updateBallTrail() {
      if (!particles || !settings.graphics.enableParticles) return;
      
      const positions = particles.geometry.attributes.position.array;
      const alphas = particles.geometry.attributes.alpha.array;
      const count = positions.length / 3;
      
      // Move all particles one step in the trail
      for (let i = count - 1; i > 0; i--) {
        positions[i * 3] = positions[(i - 1) * 3];
        positions[i * 3 + 1] = positions[(i - 1) * 3 + 1];
        positions[i * 3 + 2] = positions[(i - 1) * 3 + 2];
        alphas[i] = alphas[i - 1] * 0.95;
      }
      
      // Set the first particle position to the ball's current position
      positions[0] = ball.position.x;
      positions[1] = ball.position.y;
      positions[2] = ball.position.z;
      alphas[0] = 1.0;
      
      // Update the colors based on ball speed
      const speed = ball.userData.velocity.length();
      const normalizedSpeed = Math.min(1.0, speed / 15);
      const color = new THREE.Color();
      
      if (normalizedSpeed < 0.3) {
        color.setHSL(0.6, 1, 0.5); // Blue
      } else if (normalizedSpeed < 0.6) {
        color.setHSL(0.3, 1, 0.5); // Green
      } else {
        color.setHSL(0.0, 1, 0.5); // Red
      }
      
      particles.material.color = color;
      
      // Update the geometry
      particles.geometry.attributes.position.needsUpdate = true;
      particles.geometry.attributes.alpha.needsUpdate = true;
    }
    
    function startGame() {
      // Hide main menu
      document.getElementById('mainMenu').style.display = 'none';
      
      // Reset game state
      resetGame();
      
      // Start the game
      gameState = 'playing';
      
      // Play background music if enabled
      if (settings.sound.enableMusic) {
        sounds.music.volume(settings.sound.musicVolume * settings.sound.masterVolume);
        sounds.music.play();
      }
      
      // Show mobile controls if on mobile device
      if (isMobile) {
        document.getElementById('mobileControls').style.display = 'flex';
        setupMobileControls();
      }
      
      // Connect to multiplayer server if multiplayer mode
      if (isMultiplayer) {
        connectToMultiplayerServer();
      }
    }
    
    function resetGame() {
      // Reset scores
      leftScore = 0;
      rightScore = 0;
      updateScoreDisplay();
      
      // Reset ball
      resetBall();
      
      // Reset paddles
      resetPaddles();
      
      // Clear power-ups
      clearPowerUps();
      
      // Reset timer
      powerUpTimer = 0;
    }
    
    function resetBall() {
      // Position ball at the center
      ball.position.set(0, 0, 0);
      
      // Set random direction
      const angle = (Math.random() - 0.5) * Math.PI / 2;
      const direction = Math.random() < 0.5 ? 1 : -1;
      
      ball.userData.velocity.x = Math.cos(angle) * settings.game.baseBallSpeed * direction;
      ball.userData.velocity.y = Math.sin(angle) * settings.game.baseBallSpeed / 2;
      ball.userData.velocity.z = 0;
      
      ball.userData.baseSpeed = settings.game.baseBallSpeed;
      ball.userData.speed = settings.game.baseBallSpeed;
      ball.userData.isGhost = false;
      ball.userData.ghostOpacity = 1;
      
      // Reset material
      ball.material.opacity = 0.9;
      
      // Add ball to the scene if it was removed
      if (!ball.parent) {
        gameScene.add(ball);
      }
    }
    
    function resetPaddles() {
      // Reset paddle positions
      leftPaddle.position.y = 0;
      rightPaddle.position.y = 0;
      
      // Reset paddle properties
      leftPaddle.userData.speed = PADDLE_SPEED;
      leftPaddle.userData.direction = 0;
      leftPaddle.userData.height = PADDLE_HEIGHT;
      leftPaddle.userData.activePowerUps = [];
      leftPaddle.userData.isFrozen = false;
      leftPaddle.userData.frozenUntil = 0;
      
      rightPaddle.userData.speed = PADDLE_SPEED;
      rightPaddle.userData.direction = 0;
      rightPaddle.userData.height = PADDLE_HEIGHT;
      rightPaddle.userData.activePowerUps = [];
      rightPaddle.userData.isFrozen = false;
      rightPaddle.userData.frozenUntil = 0;
      
      // Reset paddle scale
      leftPaddle.scale.y = 1;
      rightPaddle.scale.y = 1;
      
      // Set AI according to game mode
      updateGameMode();
    }
    
    function clearPowerUps() {
      // Remove all power-up meshes from the scene
      for (let i = powerUps.length - 1; i >= 0; i--) {
        gameScene.remove(powerUps[i].mesh);
      }
      
      // Clear the power-ups array
      powerUps = [];
      
      // Remove all gravity wells
      for (let i = gravityWells.length - 1; i >= 0; i--) {
        gameScene.remove(gravityWells[i].mesh);
      }
      
      // Clear the gravity wells array
      gravityWells = [];
      
      // Remove all multi-balls
      for (let i = multiBalls.length - 1; i >= 0; i--) {
        gameScene.remove(multiBalls[i].mesh);
      }
      
      // Clear the multi-balls array
      multiBalls = [];
      
      // Clear power-up displays
      document.getElementById('leftPowerUps').innerHTML = '';
      document.getElementById('rightPowerUps').innerHTML = '';
    }
    
    function updateGameMode() {
      switch (currentGameMode) {
        case 'ai-vs-ai':
          leftPaddle.userData.isAI = true;
          rightPaddle.userData.isAI = true;
          break;
        case 'human-vs-ai':
          leftPaddle.userData.isAI = false;
          rightPaddle.userData.isAI = true;
          break;
        case 'ai-vs-human':
          leftPaddle.userData.isAI = true;
          rightPaddle.userData.isAI = false;
          break;
        case 'human-vs-human':
          leftPaddle.userData.isAI = false;
          rightPaddle.userData.isAI = false;
          break;
        case 'multiplayer':
          leftPaddle.userData.isAI = false; // Local player
          rightPaddle.userData.isAI = false; // Remote player
          isMultiplayer = true;
          break;
      }
      
      updateScoreDisplay();
    }
    
    function setGameMode(mode) {
      // Update buttons
      document.querySelectorAll('#gameModeButtons button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(mode).classList.add('active');
      
      // Set game mode
      currentGameMode = mode;
      isMultiplayer = (mode === 'multiplayer');
      
      // Update game mode
      updateGameMode();
      
      // Show notification
      let modeName = mode.split('-').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
      if (mode === 'multiplayer') modeName = 'Online Multiplayer';
      
      showNotification('Game Mode Changed', `Switched to ${modeName} mode`, 'info');
    }
    
    function connectToMultiplayerServer() {
      // Show connecting notification
      showNotification('Connecting', 'Connecting to multiplayer server...', 'info');
      
      // Simulate connection (Would be replaced with actual socket.io connection)
      setTimeout(() => {
        showNotification('Connected', 'Waiting for opponent...', 'success');
        
        // Simulate finding an opponent
        setTimeout(() => {
          showNotification('Opponent Found', 'Player GamerXYZ has joined!', 'success');
          // Game would start here
        }, 3000);
      }, 1500);
    }
    
    function updateScoreDisplay() {
      const leftScoreElement = document.querySelector('.player-score.left');
      const rightScoreElement = document.querySelector('.player-score.right');
      
      leftScoreElement.textContent = leftScore;
      rightScoreElement.textContent = rightScore;
      
      // Update score labels based on game mode
      let leftLabel, rightLabel;
      
      switch (currentGameMode) {
        case 'ai-vs-ai':
          leftLabel = 'AI 1';
          rightLabel = 'AI 2';
          break;
        case 'human-vs-ai':
          leftLabel = 'YOU';
          rightLabel = 'AI';
          break;
        case 'ai-vs-human':
          leftLabel = 'AI';
          rightLabel = 'YOU';
          break;
        case 'human-vs-human':
          leftLabel = 'P1';
          rightLabel = 'P2';
          break;
        case 'multiplayer':
          leftLabel = 'YOU';
          rightLabel = 'OPP';
          break;
      }
      
      // Could add these labels to the DOM if needed
    }
    
    // Function to show and hide panels
    function showPanel(panelId) {
      document.getElementById(panelId).style.display = 'block';
    }
    
    function hidePanel(panelId) {
      document.getElementById(panelId).style.display = 'none';
    }
    
    function togglePanel(panelId) {
      const panel = document.getElementById(panelId);
      panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
    }
    
    // Handle keyboard input
    const keys = {
      w: false,
      s: false,
      ArrowUp: false,
      ArrowDown: false,
      Escape: false,
      p: false
    };
    
    window.addEventListener('keydown', (e) => {
      if (e.key in keys) {
        keys[e.key] = true;
        e.preventDefault();
      }
    });
    
    window.addEventListener('keyup', (e) => {
      if (e.key in keys) {
        keys[e.key] = false;
        e.preventDefault();
        
        // Toggle pause menu on Escape or P
        if ((e.key === 'Escape' || e.key === 'p') && gameState === 'playing') {
          togglePanel('gameModePanel');
          gameState = 'paused';
        } else if ((e.key === 'Escape' || e.key === 'p') && gameState === 'paused') {
          togglePanel('gameModePanel');
          gameState = 'playing';
        }
      }
    });
    
    function setupMobileControls() {
      // Set up touch events for mobile controls
      const leftUp = document.getElementById('leftPaddleUp');
      const leftDown = document.getElementById('leftPaddleDown');
      const rightUp = document.getElementById('rightPaddleUp');
      const rightDown = document.getElementById('rightPaddleDown');
      
      // Left paddle up button
      leftUp.addEventListener('touchstart', () => {
        keys.w = true;
      });
      leftUp.addEventListener('touchend', () => {
        keys.w = false;
      });
      
      // Left paddle down button
      leftDown.addEventListener('touchstart', () => {
        keys.s = true;
      });
      leftDown.addEventListener('touchend', () => {
        keys.s = false;
      });
      
      // Right paddle up button
      rightUp.addEventListener('touchstart', () => {
        keys.ArrowUp = true;
      });
      rightUp.addEventListener('touchend', () => {
        keys.ArrowUp = false;
      });
      
      // Right paddle down button
      rightDown.addEventListener('touchstart', () => {
        keys.ArrowDown = true;
      });
      rightDown.addEventListener('touchend', () => {
        keys.ArrowDown = false;
      });
    }
    
    function updateHumanPaddles() {
      // Left paddle control with W/S keys
      if (!leftPaddle.userData.isAI) {
        leftPaddle.userData.direction = 0;
        if (keys.w) leftPaddle.userData.direction = 1;
        if (keys.s) leftPaddle.userData.direction = -1;
      }
      
      // Right paddle control with arrow keys
      if (!rightPaddle.userData.isAI) {
        rightPaddle.userData.direction = 0;
        if (keys.ArrowUp) rightPaddle.userData.direction = 1;
        if (keys.ArrowDown) rightPaddle.userData.direction = -1;
      }
    }
    
    function updateAIPaddles() {
      // Update AI for left paddle if AI-controlled
      if (leftPaddle.userData.isAI) {
        const predictedY = predictBallPosition(leftPaddle);
        const difficultyFactor = getAIDifficultyFactor(leftPaddle.userData.difficulty);
        
        // Add error based on difficulty
        const maxError = (1.0 - difficultyFactor) * 15;
        const aiError = THREE.MathUtils.randFloatSpread(maxError);
        
        const targetY = predictedY + aiError;
        const currentY = leftPaddle.position.y;
        const difference = targetY - currentY;
        
        if (Math.abs(difference) < 0.5) {
          leftPaddle.userData.direction = 0;
        } else {
          leftPaddle.userData.direction = difference > 0 ? 1 : -1;
        }
      }
      
      // Update AI for right paddle if AI-controlled
      if (rightPaddle.userData.isAI) {
        const predictedY = predictBallPosition(rightPaddle);
        const difficultyFactor = getAIDifficultyFactor(rightPaddle.userData.difficulty);
        
        // Add error based on difficulty
        const maxError = (1.0 - difficultyFactor) * 15;
        const aiError = THREE.MathUtils.randFloatSpread(maxError);
        
        const targetY = predictedY + aiError;
        const currentY = rightPaddle.position.y;
        const difference = targetY - currentY;
        
        if (Math.abs(difference) < 0.5) {
          rightPaddle.userData.direction = 0;
        } else {
          rightPaddle.userData.direction = difference > 0 ? 1 : -1;
        }
      }
    }
    
    function predictBallPosition(paddle) {
      if (ball.userData.velocity.x === 0) return paddle.position.y;
      
      const isLeftPaddle = (paddle === leftPaddle);
      
      // Only predict if the ball is moving toward this paddle
      if ((isLeftPaddle && ball.userData.velocity.x >= 0) || 
          (!isLeftPaddle && ball.userData.velocity.x <= 0)) {
        return paddle.position.y;
      }
      
      // Calculate distance to paddle
      const paddleX = isLeftPaddle ? leftPaddle.position.x + PADDLE_WIDTH / 2 : rightPaddle.position.x - PADDLE_WIDTH / 2;
      const distanceX = Math.abs(paddleX - ball.position.x);
      
      // Calculate time to reach paddle
      const timeToReach = distanceX / Math.abs(ball.userData.velocity.x);
      
      // Predict ball Y position at the paddle
      let predictedY = ball.position.y + ball.userData.velocity.y * timeToReach;
      
      // Account for bounces off the top and bottom walls
      const halfFieldHeight = FIELD_HEIGHT / 2 - BALL_RADIUS;
      while (Math.abs(predictedY) > halfFieldHeight) {
        if (predictedY > halfFieldHeight) {
          predictedY = 2 * halfFieldHeight - predictedY;
        } else if (predictedY < -halfFieldHeight) {
          predictedY = -2 * halfFieldHeight - predictedY;
        }
      }
      
      // For harder difficulties, try to aim for power-ups or strategic positions
      const difficultyFactor = getAIDifficultyFactor(paddle.userData.difficulty);
      if (difficultyFactor > 0.7 && Math.random() < difficultyFactor * 0.3) {
        // Look for nearby power-ups
        for (const powerUp of powerUps) {
          const isSameSide = (isLeftPaddle && powerUp.x < 0) || (!isLeftPaddle && powerUp.x > 0);
          if (isSameSide && Math.random() < 0.8) {
            predictedY = THREE.MathUtils.lerp(predictedY, powerUp.mesh.position.y, 0.5);
            break;
          }
        }
      }
      
      return predictedY;
    }
    
    function getAIDifficultyFactor(difficulty) {
      switch (difficulty) {
        case 'easy': return 0.3;
        case 'normal': return 0.6;
        case 'hard': return 0.8;
        case 'insane': return 0.95;
        case 'adaptive': return 0.5 + (Math.sin(Date.now() * 0.0005) + 1) * 0.25;
        default: return 0.6;
      }
    }
    
    function updatePaddles(deltaTime) {
      // Update paddle positions based on their direction and speed
      if (!leftPaddle.userData.isFrozen || Date.now() > leftPaddle.userData.frozenUntil) {
        leftPaddle.position.y += leftPaddle.userData.direction * leftPaddle.userData.speed * deltaTime * settings.game.gameSpeed;
      }
      
      if (!rightPaddle.userData.isFrozen || Date.now() > rightPaddle.userData.frozenUntil) {
        rightPaddle.position.y += rightPaddle.userData.direction * rightPaddle.userData.speed * deltaTime * settings.game.gameSpeed;
      }
      
      // Constrain paddle positions to the game field
      const paddleHalfHeight = leftPaddle.userData.height / 2;
      const fieldHalfHeight = FIELD_HEIGHT / 2 - 1;
      
      leftPaddle.position.y = Math.max(-fieldHalfHeight + paddleHalfHeight, 
                               Math.min(fieldHalfHeight - paddleHalfHeight, leftPaddle.position.y));
      
      rightPaddle.position.y = Math.max(-fieldHalfHeight + paddleHalfHeight, 
                                Math.min(fieldHalfHeight - paddleHalfHeight, rightPaddle.position.y));
      
      // Apply power-up effects to paddles
      updatePaddlePowerUps();
    }
    
    function updatePaddlePowerUps() {
      // Update left paddle power-ups
      leftPaddle.userData.activePowerUps = leftPaddle.userData.activePowerUps.filter(pu => Date.now() < pu.endTime);
      
      // Update right paddle power-ups
      rightPaddle.userData.activePowerUps = rightPaddle.userData.activePowerUps.filter(pu => Date.now() < pu.endTime);
      
      // Apply speed power-up
      leftPaddle.userData.speed = PADDLE_SPEED * (1 + (leftPaddle.userData.activePowerUps.some(pu => pu.type === 'speed') ? 
                                leftPaddle.userData.activePowerUps.find(pu => pu.type === 'speed').strength : 0));
      
      rightPaddle.userData.speed = PADDLE_SPEED * (1 + (rightPaddle.userData.activePowerUps.some(pu => pu.type === 'speed') ? 
                                 rightPaddle.userData.activePowerUps.find(pu => pu.type === 'speed').strength : 0));
      
      // Apply shrink power-up (reduces paddle height)
      const leftShrinkEffect = leftPaddle.userData.activePowerUps.some(pu => pu.type === 'shrink') ? 
                             leftPaddle.userData.activePowerUps.find(pu => pu.type === 'shrink').strength : 0;
      
      const rightShrinkEffect = rightPaddle.userData.activePowerUps.some(pu => pu.type === 'shrink') ? 
                              rightPaddle.userData.activePowerUps.find(pu => pu.type === 'shrink').strength : 0;
      
      // Apply giant power-up (increases paddle height)
      const leftGiantEffect = leftPaddle.userData.activePowerUps.some(pu => pu.type === 'giant') ? 
                            leftPaddle.userData.activePowerUps.find(pu => pu.type === 'giant').strength : 0;
      
      const rightGiantEffect = rightPaddle.userData.activePowerUps.some(pu => pu.type === 'giant') ? 
                             rightPaddle.userData.activePowerUps.find(pu => pu.type === 'giant').strength : 0;
      
      // Calculate final paddle height (apply shrink first, then giant)
      leftPaddle.userData.height = PADDLE_HEIGHT * (1 - leftShrinkEffect) * (1 + leftGiantEffect);
      rightPaddle.userData.height = PADDLE_HEIGHT * (1 - rightShrinkEffect) * (1 + rightGiantEffect);
      
      // Update paddle scale
      leftPaddle.scale.y = leftPaddle.userData.height / PADDLE_HEIGHT;
      rightPaddle.scale.y = rightPaddle.userData.height / PADDLE_HEIGHT;
      
      // Update visual effects for power-ups
      updatePowerUpVisuals();
    }
    
    function updatePowerUpVisuals() {
      // Update power-up displays
      const leftDisplay = document.getElementById('leftPowerUps');
      const rightDisplay = document.getElementById('rightPowerUps');
      
      leftDisplay.innerHTML = '';
      rightDisplay.innerHTML = '';
      
      // Add power-up icons to the left display
      leftPaddle.userData.activePowerUps.forEach(pu => {
        const icon = document.createElement('div');
        icon.className = 'power-up-icon';
        
        // Set color based on power-up type
        let color;
        let iconClass;
        
        switch (pu.type) {
          case 'speed': color = '#ffeb3b'; iconClass = 'fas fa-bolt'; break;
          case 'ballSpeed': color = '#f44336'; iconClass = 'fas fa-fire'; break;
          case 'shrink': color = '#800080'; iconClass = 'fas fa-compress-arrows-alt'; break;
          case 'shield': color = '#2196F3'; iconClass = 'fas fa-shield-alt'; break;
          case 'magnet': color = '#4CAF50'; iconClass = 'fas fa-magnet'; break;
          case 'giant': color = '#FF9800'; iconClass = 'fas fa-expand-arrows-alt'; break;
          case 'ghost': color = '#FFFFFF'; iconClass = 'fas fa-ghost'; break;
          case 'multiBall': color = '#00FFFF'; iconClass = 'fas fa-clone'; break;
          case 'freeze': color = '#008080'; iconClass = 'fas fa-snowflake'; break;
          case 'gravity': color = '#8000FF'; iconClass = 'fas fa-atom'; break;
          case 'timeSlow': color = '#00FF00'; iconClass = 'fas fa-hourglass-half'; break;
          case 'teleport': color = '#FF00FF'; iconClass = 'fas fa-random'; break;
          case 'superShot': color = '#FF3300'; iconClass = 'fas fa-rocket'; break;
          case 'mirror': color = '#AAAAAA'; iconClass = 'fas fa-exchange-alt'; break;
          case 'obstacle': color = '#663300'; iconClass = 'fas fa-ban'; break;
          default: color = '#ffffff'; iconClass = 'fas fa-question'; break;
        }
        
        icon.style.borderColor = color;
        icon.innerHTML = `<i class="${iconClass}" style="color:${color}; font-size:24px;"></i>`;
        
        // Add timer
        const timeRemaining = Math.ceil((pu.endTime - Date.now()) / 1000);
        icon.style.setProperty('--timer-count', `'${timeRemaining}'`);
        icon.setAttribute('data-time', timeRemaining);
        
        leftDisplay.appendChild(icon);
      });
      
      // Add power-up icons to the right display
      rightPaddle.userData.activePowerUps.forEach(pu => {
        const icon = document.createElement('div');
        icon.className = 'power-up-icon';
        
        // Set color based on power-up type
        let color;
        let iconClass;
        
        switch (pu.type) {
          case 'speed': color = '#ffeb3b'; iconClass = 'fas fa-bolt'; break;
          case 'ballSpeed': color = '#f44336'; iconClass = 'fas fa-fire'; break;
          case 'shrink': color = '#800080'; iconClass = 'fas fa-compress-arrows-alt'; break;
          case 'shield': color = '#2196F3'; iconClass = 'fas fa-shield-alt'; break;
          case 'magnet': color = '#4CAF50'; iconClass = 'fas fa-magnet'; break;
          case 'giant': color = '#FF9800'; iconClass = 'fas fa-expand-arrows-alt'; break;
          case 'ghost': color = '#FFFFFF'; iconClass = 'fas fa-ghost'; break;
          case 'multiBall': color = '#00FFFF'; iconClass = 'fas fa-clone'; break;
          case 'freeze': color = '#008080'; iconClass = 'fas fa-snowflake'; break;
          case 'gravity': color = '#8000FF'; iconClass = 'fas fa-atom'; break;
          case 'timeSlow': color = '#00FF00'; iconClass = 'fas fa-hourglass-half'; break;
          case 'teleport': color = '#FF00FF'; iconClass = 'fas fa-random'; break;
          case 'superShot': color = '#FF3300'; iconClass = 'fas fa-rocket'; break;
          case 'mirror': color = '#AAAAAA'; iconClass = 'fas fa-exchange-alt'; break;
          case 'obstacle': color = '#663300'; iconClass = 'fas fa-ban'; break;
          default: color = '#ffffff'; iconClass = 'fas fa-question'; break;
        }
        
        icon.style.borderColor = color;
        icon.innerHTML = `<i class="${iconClass}" style="color:${color}; font-size:24px;"></i>`;
        
        // Add timer
        const timeRemaining = Math.ceil((pu.endTime - Date.now()) / 1000);
        icon.style.setProperty('--timer-count', `'${timeRemaining}'`);
        icon.setAttribute('data-time', timeRemaining);
        
        rightDisplay.appendChild(icon);
      });
      
      // Update paddle materials based on active power-ups
      const leftPowerUpType = leftPaddle.userData.activePowerUps.length > 0 ? 
                             leftPaddle.userData.activePowerUps[leftPaddle.userData.activePowerUps.length - 1].type : null;
      
      const rightPowerUpType = rightPaddle.userData.activePowerUps.length > 0 ? 
                              rightPaddle.userData.activePowerUps[rightPaddle.userData.activePowerUps.length - 1].type : null;
      
      // Update left paddle material
      const leftEmissiveColor = new THREE.Color(0x00fcff);
      
      if (leftPowerUpType) {
        switch (leftPowerUpType) {
          case 'speed': leftEmissiveColor.set(0xffeb3b); break;
          case 'shield': leftEmissiveColor.set(0x2196F3); break;
          case 'magnet': leftEmissiveColor.set(0x4CAF50); break;
          case 'giant': leftEmissiveColor.set(0xFF9800); break;
          case 'freeze': leftEmissiveColor.set(0x008080); break;
        }
        
        leftPaddle.material.emissive = leftEmissiveColor;
        leftPaddle.material.emissiveIntensity = 0.8;
      } else {
        leftPaddle.material.emissive.set(0x00fcff);
        leftPaddle.material.emissiveIntensity = 0.5;
      }
      
      // Update right paddle material
      const rightEmissiveColor = new THREE.Color(0xff00ff);
      
      if (rightPowerUpType) {
        switch (rightPowerUpType) {
          case 'speed': rightEmissiveColor.set(0xffeb3b); break;
          case 'shield': rightEmissiveColor.set(0x2196F3); break;
          case 'magnet': rightEmissiveColor.set(0x4CAF50); break;
          case 'giant': rightEmissiveColor.set(0xFF9800); break;
          case 'freeze': rightEmissiveColor.set(0x008080); break;
        }
        
        rightPaddle.material.emissive = rightEmissiveColor;
        rightPaddle.material.emissiveIntensity = 0.8;
      } else {
        rightPaddle.material.emissive.set(0xff00ff);
        rightPaddle.material.emissiveIntensity = 0.5;
      }
    }

    function updateBall(deltaTime) {
      // Move the ball based on its velocity
      ball.position.x += ball.userData.velocity.x * deltaTime * settings.game.gameSpeed;
      ball.position.y += ball.userData.velocity.y * deltaTime * settings.game.gameSpeed;
      
      // Check collision with top and bottom walls
      const fieldHalfHeight = FIELD_HEIGHT / 2 - BALL_RADIUS;
      if (ball.position.y > fieldHalfHeight || ball.position.y < -fieldHalfHeight) {
        ball.userData.velocity.y *= -1;
        
        // Add randomness to bounce based on settings
        ball.userData.velocity.y += (Math.random() - 0.5) * (settings.game.randomnessLevel / 50);
        
        // Play wall collision sound
        playSoundWithVolume(sounds.wall);
        
        // Add visual effect for wall hit
        createImpactEffect(ball.position.x, ball.position.y > 0 ? fieldHalfHeight : -fieldHalfHeight, 0, 0x00ffff);
      }
      
      // Check for paddle collisions
      checkPaddleCollisions();
      
      // Check for scoring
      checkScoring();
      
      // Apply magnet effect if active
      applyMagnetEffect();
      
      // Update ball ghost effect if active
      if (ball.userData.isGhost) {
        ball.material.opacity = ball.userData.ghostOpacity;
      }
      
      // Update ball trail
      updateBallTrail();
    }
    
    function checkPaddleCollisions() {
      // Left paddle collision
      if (ball.position.x - BALL_RADIUS <= leftPaddle.position.x + PADDLE_WIDTH / 2 &&
          ball.position.x > leftPaddle.position.x - PADDLE_WIDTH / 2 &&
          ball.position.y >= leftPaddle.position.y - leftPaddle.userData.height / 2 &&
          ball.position.y <= leftPaddle.position.y + leftPaddle.userData.height / 2) {
        
        // Calculate hit point relative to paddle center
        const relativeHitPoint = (ball.position.y - leftPaddle.position.y) / (leftPaddle.userData.height / 2);
        
        // Add randomness based on settings
        const randomFactor = (Math.random() - 0.5) * (settings.game.randomnessLevel / 100) * Math.PI;
        let angle = relativeHitPoint * (70 * Math.PI / 180) + randomFactor;
        
        // Rally speedup
        const quadraticRallyFactor = Math.min(5, 1 + Math.pow(consecutiveHitCount / 10, 2));
        const extraSpeed = consecutiveHitCount * settings.game.extraSpeedFactor * quadraticRallyFactor;
        
        // Add paddle movement influence
        const paddleInfluence = Math.abs(leftPaddle.userData.direction) * 0.3;
        const newSpeed = ball.userData.speed + paddleInfluence + extraSpeed;
        
        // Apply new velocity
        ball.userData.velocity.x = Math.abs(newSpeed * Math.cos(angle));
        ball.userData.velocity.y = newSpeed * Math.sin(angle);
        
        // Increment hit count and play sound
        consecutiveHitCount++;
        playSoundWithVolume(sounds.paddle);
        
        // Add visual effect for paddle hit
        createImpactEffect(leftPaddle.position.x + PADDLE_WIDTH / 2, ball.position.y, 0, 0x00ffff);
      }
      
      // Right paddle collision
      if (ball.position.x + BALL_RADIUS >= rightPaddle.position.x - PADDLE_WIDTH / 2 &&
          ball.position.x < rightPaddle.position.x + PADDLE_WIDTH / 2 &&
          ball.position.y >= rightPaddle.position.y - rightPaddle.userData.height / 2 &&
          ball.position.y <= rightPaddle.position.y + rightPaddle.userData.height / 2) {
        
        // Calculate hit point relative to paddle center
        const relativeHitPoint = (ball.position.y - rightPaddle.position.y) / (rightPaddle.userData.height / 2);
        
        // Add randomness based on settings
        const randomFactor = (Math.random() - 0.5) * (settings.game.randomnessLevel / 100) * Math.PI;
        let angle = relativeHitPoint * (70 * Math.PI / 180) + randomFactor;
        
        // Rally speedup
        const quadraticRallyFactor = Math.min(5, 1 + Math.pow(consecutiveHitCount / 10, 2));
        const extraSpeed = consecutiveHitCount * settings.game.extraSpeedFactor * quadraticRallyFactor;
        
        // Add paddle movement influence
        const paddleInfluence = Math.abs(rightPaddle.userData.direction) * 0.3;
        const newSpeed = ball.userData.speed + paddleInfluence + extraSpeed;
        
        // Apply new velocity
        ball.userData.velocity.x = -Math.abs(newSpeed * Math.cos(angle));
        ball.userData.velocity.y = newSpeed * Math.sin(angle);
        
        // Increment hit count and play sound
        consecutiveHitCount++;
        playSoundWithVolume(sounds.paddle);
        
        // Add visual effect for paddle hit
        createImpactEffect(rightPaddle.position.x - PADDLE_WIDTH / 2, ball.position.y, 0, 0xff00ff);
      }
    }
    
    function checkScoring() {
      // Ball goes past left paddle
      if (ball.position.x < -FIELD_WIDTH / 2) {
        // Check if left paddle has shield
        const shieldEffect = leftPaddle.userData.activePowerUps.find(pu => pu.type === 'shield');
        if (shieldEffect) {
          // Use up shield
          if (shieldEffect.count > 1) {
            shieldEffect.count--;
          } else {
            leftPaddle.userData.activePowerUps = leftPaddle.userData.activePowerUps.filter(pu => pu.type !== 'shield');
          }
          
          // Bounce ball back
          ball.userData.velocity.x = Math.abs(ball.userData.velocity.x);
          ball.position.x = -FIELD_WIDTH / 2 + BALL_RADIUS + 1;
          
          // Play shield sound and create visual effect
          playSoundWithVolume(sounds.paddle);
          createImpactEffect(ball.position.x, ball.position.y, 0, 0x2196F3);
        } else {
          // Score point for right player
          rightScore++;
          updateScoreDisplay();
          
          // Play score sound
          playSoundWithVolume(sounds.score);
          
          // Show score effect
          createScoreEffect(rightScore, 'right');
          
          // Reset for next round
          resetBall();
          consecutiveHitCount = 0;
          
          // Check for game end
          if (rightScore >= settings.game.maxPoints) {
            endGame('right');
          }
        }
      }
      
      // Ball goes past right paddle
      if (ball.position.x > FIELD_WIDTH / 2) {
        // Check if right paddle has shield
        const shieldEffect = rightPaddle.userData.activePowerUps.find(pu => pu.type === 'shield');
        if (shieldEffect) {
          // Use up shield
          if (shieldEffect.count > 1) {
            shieldEffect.count--;
          } else {
            rightPaddle.userData.activePowerUps = rightPaddle.userData.activePowerUps.filter(pu => pu.type !== 'shield');
          }
          
          // Bounce ball back
          ball.userData.velocity.x = -Math.abs(ball.userData.velocity.x);
          ball.position.x = FIELD_WIDTH / 2 - BALL_RADIUS - 1;
          
          // Play shield sound and create visual effect
          playSoundWithVolume(sounds.paddle);
          createImpactEffect(ball.position.x, ball.position.y, 0, 0x2196F3);
        } else {
          // Score point for left player
          leftScore++;
          updateScoreDisplay();
          
          // Play score sound
          playSoundWithVolume(sounds.score);
          
          // Show score effect
          createScoreEffect(leftScore, 'left');
          
          // Reset for next round
          resetBall();
          consecutiveHitCount = 0;
          
          // Check for game end
          if (leftScore >= settings.game.maxPoints) {
            endGame('left');
          }
        }
      }
    }
    
    function createImpactEffect(x, y, z, color) {
      if (!settings.graphics.enableParticles) return;
      
      // Create a burst of particles at the impact point
      const particleCount = 20;
      const particles = new THREE.Group();
      
      for (let i = 0; i < particleCount; i++) {
        const size = Math.random() * 0.5 + 0.2;
        const speed = Math.random() * 2 + 1;
        const angle = Math.random() * Math.PI * 2;
        const elevation = Math.random() * Math.PI - Math.PI / 2;
        
        const particle = new THREE.Mesh(
          new THREE.SphereGeometry(size, 8, 8),
          new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8
          })
        );
        
        particle.position.set(x, y, z);
        particle.userData.velocity = new THREE.Vector3(
          Math.cos(angle) * Math.cos(elevation) * speed,
          Math.sin(elevation) * speed,
          Math.sin(angle) * Math.cos(elevation) * speed
        );
        particle.userData.life = 1.0;
        
        particles.add(particle);
      }
      
      gameScene.add(particles);
      
      // Animate and fade out
      const animateParticles = function() {
        for (let i = particles.children.length - 1; i >= 0; i--) {
          const p = particles.children[i];
          
          p.position.x += p.userData.velocity.x * 0.1;
          p.position.y += p.userData.velocity.y * 0.1;
          p.position.z += p.userData.velocity.z * 0.1;
          
          p.userData.life -= 0.03;
          p.material.opacity = p.userData.life;
          
          if (p.userData.life <= 0) {
            particles.remove(p);
          }
        }
        
        if (particles.children.length > 0) {
          requestAnimationFrame(animateParticles);
        } else {
          gameScene.remove(particles);
        }
      };
      
      animateParticles();
    }
    
    function createScoreEffect(score, side) {
      // Create floating score text
      const textElement = document.createElement('div');
      textElement.className = 'score-popup';
      textElement.textContent = score.toString();
      document.body.appendChild(textElement);
      
      // Position near the scoring player's side
      const x = side === 'left' ? '25%' : '75%';
      
      // Set style
      textElement.style.position = 'absolute';
      textElement.style.left = x;
      textElement.style.top = '40%';
      textElement.style.fontSize = '80px';
      textElement.style.fontWeight = 'bold';
      textElement.style.color = side === 'left' ? 'var(--primary)' : 'var(--secondary)';
      textElement.style.textShadow = '0 0 20px ' + (side === 'left' ? 'var(--primary)' : 'var(--secondary)');
      textElement.style.opacity = '0';
      textElement.style.zIndex = '100';
      textElement.style.pointerEvents = 'none';
      textElement.style.transition = 'all 0.5s ease-out';
      
      // Animate
      setTimeout(() => {
        textElement.style.opacity = '1';
        textElement.style.transform = 'translateY(-50px) scale(1.5)';
      }, 10);
      
      // Remove after animation
      setTimeout(() => {
        textElement.style.opacity = '0';
        setTimeout(() => {
          document.body.removeChild(textElement);
        }, 500);
      }, 1000);
    }
    
    function applyMagnetEffect() {
      // Apply magnet power-up for left paddle
      if (leftPaddle.userData.activePowerUps.some(pu => pu.type === 'magnet')) {
        const magnetEffect = leftPaddle.userData.activePowerUps.find(pu => pu.type === 'magnet');
        
        // Only affect ball when it's in the left half of the field
        if (ball.position.x < 0) {
          const targetY = leftPaddle.position.y;
          const diff = targetY - ball.position.y;
          ball.userData.velocity.y += diff * (magnetEffect.strength * 0.0005);
        }
      }
      
      // Apply magnet power-up for right paddle
      if (rightPaddle.userData.activePowerUps.some(pu => pu.type === 'magnet')) {
        const magnetEffect = rightPaddle.userData.activePowerUps.find(pu => pu.type === 'magnet');
        
        // Only affect ball when it's in the right half of the field
        if (ball.position.x > 0) {
          const targetY = rightPaddle.position.y;
          const diff = targetY - ball.position.y;
          ball.userData.velocity.y += diff * (magnetEffect.strength * 0.0005);
        }
      }
    }
    
    function updatePowerUps(deltaTime) {
      // Update power-up timer
      powerUpTimer += deltaTime * 1000 * settings.game.gameSpeed;
      
      // Spawn a new power-up if it's time
      if (powerUpTimer >= settings.powerUps.powerUpFrequency) {
        spawnPowerUp();
        powerUpTimer = 0;
      }
      
      // Update existing power-ups
      for (let i = powerUps.length - 1; i >= 0; i--) {
        const powerUp = powerUps[i];
        
        // Rotate power-up for visual effect
        powerUp.mesh.rotation.y += 0.02;
        
        // Bobbing motion
        powerUp.mesh.position.y = powerUp.y + Math.sin(Date.now() * 0.003) * 0.5;
        
        // Check for collision with ball
        if (powerUp.mesh.position.distanceTo(ball.position) < BALL_RADIUS + 2) {
          // Apply power-up effect
          applyPowerUpEffect(powerUp);
          
          // Play power-up sound
          playSoundWithVolume(sounds.powerUp);
          
          // Remove power-up from scene and array
          gameScene.remove(powerUp.mesh);
          powerUps.splice(i, 1);
        }
      }
      
      // Update gravity wells
      for (let i = gravityWells.length - 1; i >= 0; i--) {
        const well = gravityWells[i];
        
        // Remove expired gravity wells
        if (Date.now() > well.expiresAt) {
          gameScene.remove(well.mesh);
          gravityWells.splice(i, 1);
          continue;
        }
        
        // Apply gravity effect to ball
        const dx = well.mesh.position.x - ball.position.x;
        const dy = well.mesh.position.y - ball.position.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < well.radius) {
          // Calculate gravitational force
          const force = well.strength * (1 - distance / well.radius) * 0.2;
          ball.userData.velocity.x += (dx / distance) * force;
          ball.userData.velocity.y += (dy / distance) * force;
        }
        
        // Update gravity well visual effect
        const pulseScale = 1 + Math.sin(Date.now() * 0.005) * 0.1;
        well.mesh.scale.set(pulseScale, pulseScale, pulseScale);
      }
      
      // Update multi-balls
      for (let i = multiBalls.length - 1; i >= 0; i--) {
        const mb = multiBalls[i];
        
        // Remove expired multi-balls
        if (Date.now() > mb.expiresAt) {
          gameScene.remove(mb.mesh);
          multiBalls.splice(i, 1);
          continue;
        }
        
        // Move multi-ball
        mb.mesh.position.x += mb.velocity.x * deltaTime * settings.game.gameSpeed;
        mb.mesh.position.y += mb.velocity.y * deltaTime * settings.game.gameSpeed;
        
        // Check collisions with walls
        const fieldHalfHeight = FIELD_HEIGHT / 2 - BALL_RADIUS;
        if (mb.mesh.position.y > fieldHalfHeight || mb.mesh.position.y < -fieldHalfHeight) {
          mb.velocity.y *= -1;
          
          // Add randomness to bounce
          mb.velocity.y += (Math.random() - 0.5) * (settings.game.randomnessLevel / 50);
        }
        
        // Check collisions with paddles
        // Left paddle collision
        if (mb.mesh.position.x - BALL_RADIUS <= leftPaddle.position.x + PADDLE_WIDTH / 2 &&
            mb.mesh.position.x > leftPaddle.position.x - PADDLE_WIDTH / 2 &&
            mb.mesh.position.y >= leftPaddle.position.y - leftPaddle.userData.height / 2 &&
            mb.mesh.position.y <= leftPaddle.position.y + leftPaddle.userData.height / 2) {
          
          // Calculate hit point relative to paddle center
          const relativeHitPoint = (mb.mesh.position.y - leftPaddle.position.y) / (leftPaddle.userData.height / 2);
          
          // Add randomness based on settings
          const randomFactor = (Math.random() - 0.5) * (settings.game.randomnessLevel / 100) * Math.PI;
          let angle = relativeHitPoint * (70 * Math.PI / 180) + randomFactor;
          
          // Apply new velocity
          mb.velocity.x = Math.abs(mb.speed * Math.cos(angle));
          mb.velocity.y = mb.speed * Math.sin(angle);
          
          // Play paddle hit sound
          playSoundWithVolume(sounds.paddle, 0.5);
        }
        
        // Right paddle collision
        if (mb.mesh.position.x + BALL_RADIUS >= rightPaddle.position.x - PADDLE_WIDTH / 2 &&
            mb.mesh.position.x < rightPaddle.position.x + PADDLE_WIDTH / 2 &&
            mb.mesh.position.y >= rightPaddle.position.y - rightPaddle.userData.height / 2 &&
            mb.mesh.position.y <= rightPaddle.position.y + rightPaddle.userData.height / 2) {
          
          // Calculate hit point relative to paddle center
          const relativeHitPoint = (mb.mesh.position.y - rightPaddle.position.y) / (rightPaddle.userData.height / 2);
          
          // Add randomness based on settings
          const randomFactor = (Math.random() - 0.5) * (settings.game.randomnessLevel / 100) * Math.PI;
          let angle = relativeHitPoint * (70 * Math.PI / 180) + randomFactor;
          
          // Apply new velocity
          mb.velocity.x = -Math.abs(mb.speed * Math.cos(angle));
          mb.velocity.y = mb.speed * Math.sin(angle);
          
          // Play paddle hit sound
          playSoundWithVolume(sounds.paddle, 0.5);
        }
        
        // Check scoring for multi-balls
        if (mb.mesh.position.x < -FIELD_WIDTH / 2) {
          // Score for right player
          rightScore++;
          updateScoreDisplay();
          
          // Play score sound
          playSoundWithVolume(sounds.score, 0.5);
          
          // Remove multi-ball
          gameScene.remove(mb.mesh);
          multiBalls.splice(i, 1);
          
          // Check for game end
          if (rightScore >= settings.game.maxPoints) {
            endGame('right');
          }
        } else if (mb.mesh.position.x > FIELD_WIDTH / 2) {
          // Score for left player
          leftScore++;
          updateScoreDisplay();
          
          // Play score sound
          playSoundWithVolume(sounds.score, 0.5);
          
          // Remove multi-ball
          gameScene.remove(mb.mesh);
          multiBalls.splice(i, 1);
          
          // Check for game end
          if (leftScore >= settings.game.maxPoints) {
            endGame('left');
          }
        }
      }
    }
    
    function spawnPowerUp() {
      // Determine power-up type based on chances
      let r = Math.random();
      let cumulative = 0;
      let type;
      
      for (const [key, chance] of Object.entries(settings.powerUps.chances)) {
        if (!settings.powerUps.enabled[key]) continue;
        
        cumulative += chance / 100;
        if (r <= cumulative) {
          type = key;
          break;
        }
      }
      
      if (!type) return;
      
      // Determine which side of the field
      const x = (Math.random() - 0.5) * (FIELD_WIDTH - 20);
      const y = (Math.random() - 0.5) * (FIELD_HEIGHT - 10);
      const side = x < 0 ? 'left' : 'right';
      
      // Create power-up geometry based on type
      let geometry, material;
      
      switch (type) {
        case 'speed':
          geometry = new THREE.OctahedronGeometry(2, 0);
          material = new THREE.MeshPhongMaterial({ 
            color: 0xffeb3b, 
            emissive: 0xffeb3b,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'ballSpeed':
          geometry = new THREE.TetrahedronGeometry(2, 0);
          material = new THREE.MeshPhongMaterial({ 
            color: 0xf44336, 
            emissive: 0xf44336,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'shrink':
          geometry = new THREE.BoxGeometry(2, 3, 2);
          material = new THREE.MeshPhongMaterial({ 
            color: 0x800080, 
            emissive: 0x800080,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'shield':
          geometry = new THREE.CylinderGeometry(0, 2, 3, 6);
          material = new THREE.MeshPhongMaterial({ 
            color: 0x2196F3, 
            emissive: 0x2196F3,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'magnet':
          geometry = new THREE.TorusGeometry(1.5, 0.7, 8, 16);
          material = new THREE.MeshPhongMaterial({ 
            color: 0x4CAF50, 
            emissive: 0x4CAF50,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'giant':
          geometry = new THREE.BoxGeometry(2, 4, 2);
          material = new THREE.MeshPhongMaterial({ 
            color: 0xFF9800, 
            emissive: 0xFF9800,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'ghost':
          geometry = new THREE.SphereGeometry(2, 16, 16);
          material = new THREE.MeshPhongMaterial({ 
            color: 0xFFFFFF, 
            emissive: 0xFFFFFF,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.5
          });
          break;
        case 'multiBall':
          geometry = new THREE.IcosahedronGeometry(2, 0);
          material = new THREE.MeshPhongMaterial({ 
            color: 0x00FFFF, 
            emissive: 0x00FFFF,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'freeze':
          geometry = new THREE.DodecahedronGeometry(2, 0);
          material = new THREE.MeshPhongMaterial({ 
            color: 0x008080, 
            emissive: 0x008080,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        case 'gravity':
          geometry = new THREE.SphereGeometry(2, 16, 16);
          material = new THREE.MeshPhongMaterial({ 
            color: 0x8000FF, 
            emissive: 0x8000FF,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.9
          });
          break;
        default:
          geometry = new THREE.BoxGeometry(2, 2, 2);
          material = new THREE.MeshPhongMaterial({ 
            color: 0xFFFFFF, 
            transparent: true,
            opacity: 0.9
          });
      }
      
      // Create power-up mesh
      const powerUpMesh = new THREE.Mesh(geometry, material);
      powerUpMesh.position.set(x, y, 0);
      gameScene.add(powerUpMesh);
      
      // Calculate power-up duration and strength
      const durMin = POWER_UP_DURATIONS[type][0] * settings.powerUps.durationFactor;
      const durMax = POWER_UP_DURATIONS[type][1] * settings.powerUps.durationFactor;
      const duration = Math.random() * (durMax - durMin) + durMin;
      
      const strMin = POWER_UP_STRENGTHS[type][0] * settings.powerUps.strengthFactor;
      const strMax = POWER_UP_STRENGTHS[type][1] * settings.powerUps.strengthFactor;
      const strength = Math.random() * (strMax - strMin) + strMin;
      
      // Add power-up to array
      powerUps.push({
        type,
        x,
        y,
        side,
        mesh: powerUpMesh,
        duration,
        strength
      });
    }
    
    function applyPowerUpEffect(powerUp) {
      // Determine target paddle based on power-up type and side
      const negativeEffects = ['shrink', 'ballSpeed', 'freeze'];
      const selfPaddle = powerUp.side === 'left' ? leftPaddle : rightPaddle;
      const oppPaddle = powerUp.side === 'left' ? rightPaddle : leftPaddle;
      const targetPaddle = negativeEffects.includes(powerUp.type) ? oppPaddle : selfPaddle;
      
      // Handle existing effects
      const existingEffect = targetPaddle.userData.activePowerUps.find(p => p.type === powerUp.type);
      
      if (existingEffect && !['shield', 'magnet', 'multiBall', 'gravity'].includes(powerUp.type)) {
        // Extend duration of existing effect
        existingEffect.endTime = Date.now() + powerUp.duration;
      } else {
        // Apply new effect
        switch (powerUp.type) {
          case 'speed':
          case 'shrink':
          case 'ballSpeed':
          case 'giant':
            targetPaddle.userData.activePowerUps.push({
              type: powerUp.type,
              startTime: Date.now(),
              endTime: Date.now() + powerUp.duration,
              strength: powerUp.strength
            });
            break;
            
          case 'shield':
            let existingShield = targetPaddle.userData.activePowerUps.find(p => p.type === 'shield');
            if (existingShield) {
              existingShield.count = (existingShield.count || 1) + 1;
            } else {
              targetPaddle.userData.activePowerUps.push({
                type: 'shield',
                startTime: Date.now(),
                endTime: Date.now() + powerUp.duration,
                count: 1
              });
            }
            break;
            
          case 'magnet':
            targetPaddle.userData.activePowerUps.push({
              type: 'magnet',
              startTime: Date.now(),
              endTime: Date.now() + powerUp.duration,
              strength: powerUp.strength
            });
            break;
            
          case 'ghost':
            // Make ball semi-transparent
            ball.userData.isGhost = true;
            ball.userData.ghostOpacity = 0.4;
            setTimeout(() => {
              ball.userData.isGhost = false;
              ball.userData.ghostOpacity = 0.9;
            }, powerUp.duration);
            break;
            
          case 'multiBall':
            // Create an additional ball
            const ballGeometry = new THREE.SphereGeometry(BALL_RADIUS, BALL_SEGMENTS, BALL_SEGMENTS);
            const ballMaterial = new THREE.MeshPhongMaterial({
              color: 0x00FFFF,
              emissive: 0x00FFFF,
              emissiveIntensity: 0.5,
              transparent: true,
              opacity: 0.9
            });
            
            const newBallMesh = new THREE.Mesh(ballGeometry, ballMaterial);
            newBallMesh.position.copy(ball.position);
            
            // Set velocity at a different angle
            const angle = Math.random() * Math.PI * 2;
            const speed = ball.userData.velocity.length() * 0.9;
            
            const multiBall = {
              mesh: newBallMesh,
              velocity: new THREE.Vector3(
                Math.cos(angle) * speed,
                Math.sin(angle) * speed,
                0
              ),
              speed: speed,
              expiresAt: Date.now() + powerUp.duration
            };
            
            gameScene.add(newBallMesh);
            multiBalls.push(multiBall);
            break;
            
          case 'freeze':
            // Freeze the opponent's paddle
            targetPaddle.userData.isFrozen = true;
            targetPaddle.userData.frozenUntil = Date.now() + powerUp.duration;
            targetPaddle.userData.activePowerUps.push({
              type: 'freeze',
              startTime: Date.now(),
              endTime: Date.now() + powerUp.duration
            });
            
            // Add frozen visual effect
            targetPaddle.material.color.set(0x88CCEE);
            setTimeout(() => {
              targetPaddle.userData.isFrozen = false;
              targetPaddle.material.color.set(targetPaddle === leftPaddle ? 0x00fcff : 0xff00ff);
            }, powerUp.duration);
            break;
            
          case 'gravity':
            // Create gravity well in opponent's half
            const wellGeometry = new THREE.SphereGeometry(10, 16, 16);
            const wellMaterial = new THREE.MeshPhongMaterial({
              color: 0x8000FF,
              emissive: 0x8000FF,
              emissiveIntensity: 0.5,
              transparent: true,
              opacity: 0.2,
              wireframe: true
            });
            
            const wellMesh = new THREE.Mesh(wellGeometry, wellMaterial);
            const wellX = oppPaddle === leftPaddle ? -FIELD_WIDTH / 4 : FIELD_WIDTH / 4;
            wellMesh.position.set(wellX, 0, 0);
            
            const gravityWell = {
              mesh: wellMesh,
              radius: 20,
              strength: powerUp.strength,
              expiresAt: Date.now() + powerUp.duration
            };
            
            gameScene.add(wellMesh);
            gravityWells.push(gravityWell);
            
            // Add gravity visual effect
            const glowGeometry = new THREE.SphereGeometry(10.5, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
              color: 0x8000FF,
              transparent: true,
              opacity: 0.1,
              side: THREE.BackSide
            });
            
            const glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
            wellMesh.add(glowMesh);
            break;
        }
      }
      
      // Create power-up activation effect
      createPowerUpEffect(powerUp.mesh.position.x, powerUp.mesh.position.y, 0, powerUp.type);
    }
    
    function createPowerUpEffect(x, y, z, type) {
      if (!settings.graphics.enableParticles) return;
      
      // Determine color based on power-up type
      let color;
      switch (type) {
        case 'speed': color = 0xffeb3b; break;
        case 'ballSpeed': color = 0xf44336; break;
        case 'shrink': color = 0x800080; break;
        case 'shield': color = 0x2196F3; break;
        case 'magnet': color = 0x4CAF50; break;
        case 'giant': color = 0xFF9800; break;
        case 'ghost': color = 0xFFFFFF; break;
        case 'multiBall': color = 0x00FFFF; break;
        case 'freeze': color = 0x008080; break;
        case 'gravity': color = 0x8000FF; break;
        default: color = 0xFFFFFF;
      }
      
      // Create expanding ring effect
      const ringGeometry = new THREE.RingGeometry(0.1, 3, 32);
      const ringMaterial = new THREE.MeshBasicMaterial({
        color: color,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });
      
      const ring = new THREE.Mesh(ringGeometry, ringMaterial);
      ring.position.set(x, y, z);
      ring.rotation.x = Math.PI / 2;
      gameScene.add(ring);
      
      // Animate the ring
      const expandRing = function() {
        ring.scale.x += 0.1;
        ring.scale.y += 0.1;
        ring.scale.z += 0.1;
        ring.material.opacity -= 0.02;
        
        if (ring.material.opacity > 0) {
          requestAnimationFrame(expandRing);
        } else {
          gameScene.remove(ring);
        }
      };
      
      expandRing();
    }
    
    function endGame(winner) {
      gameState = 'finished';
      
      // Display game over panel
      const gameOverPanel = document.createElement('div');
      gameOverPanel.className = 'ui-panel';
      gameOverPanel.style.position = 'absolute';
      gameOverPanel.style.top = '50%';
      gameOverPanel.style.left = '50%';
      gameOverPanel.style.transform = 'translate(-50%, -50%)';
      gameOverPanel.style.width = '500px';
      gameOverPanel.style.zIndex = '100';
      
      // Set header
      let winnerText;
      switch(currentGameMode) {
        case 'ai-vs-ai':
          winnerText = winner === 'left' ? 'Left AI Wins!' : 'Right AI Wins!';
          break;
        case 'human-vs-ai':
          winnerText = winner === 'left' ? 'You Win!' : 'AI Wins!';
          break;
        case 'ai-vs-human':
          winnerText = winner === 'left' ? 'AI Wins!' : 'You Win!';
          break;
        case 'human-vs-human':
          winnerText = winner === 'left' ? 'Player 1 Wins!' : 'Player 2 Wins!';
          break;
        case 'multiplayer':
          winnerText = winner === 'left' ? 'You Win!' : 'Opponent Wins!';
          break;
      }
      
      gameOverPanel.innerHTML = `
        <div class="panel-header">
          <h2 class="panel-title">Game Over</h2>
        </div>
        <div class="panel-content">
          <h2 style="text-align: center; font-size: 32px; margin-bottom: 30px;">${winnerText}</h2>
          <p style="text-align: center; margin-bottom: 20px;">Final Score: ${leftScore} - ${rightScore}</p>
          <div class="btn-group">
            <button class="cyber-button" onclick="playAgain()">Play Again</button>
            <button class="cyber-button secondary" onclick="showMainMenu()">Main Menu</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(gameOverPanel);
      
      // Award credits for winning games as player
      if ((currentGameMode === 'human-vs-ai' && winner === 'left') || 
          (currentGameMode === 'ai-vs-human' && winner === 'right') ||
          (currentGameMode === 'multiplayer' && winner === 'left')) {
        const creditsEarned = 50;
        addCredits(creditsEarned);
        showNotification('Credits Earned', `You earned ${creditsEarned} credits for winning!`, 'success');
      }
      
      // Stop background music
      sounds.music.stop();
    }
    
    function playAgain() {
      // Remove game over panel
      const gameOverPanel = document.querySelector('.ui-panel[style*="z-index: 100"]');
      if (gameOverPanel) {
        document.body.removeChild(gameOverPanel);
      }
      
      // Reset and start a new game
      resetGame();
      gameState = 'playing';
      
      // Play background music if enabled
      if (settings.sound.enableMusic) {
        sounds.music.volume(settings.sound.musicVolume * settings.sound.masterVolume);
        sounds.music.play();
      }
    }
    
    function showMainMenu() {
      // Remove game over panel
      const gameOverPanel = document.querySelector('.ui-panel[style*="z-index: 100"]');
      if (gameOverPanel) {
        document.body.removeChild(gameOverPanel);
      }
      
      // Reset game
      resetGame();
      gameState = 'menu';
      
      // Show main menu
      document.getElementById('mainMenu').style.display = 'block';
    }
    
    function addCredits(amount) {
      playerCredits += amount;
      document.getElementById('playerCredits').textContent = playerCredits;
      
      // Save player data to localStorage
      savePlayerData();
    }
    
    function purchaseItem(itemId) {
      // Define item prices
      const prices = {
        'neon_paddle_pack': 200,
        'cosmic_ball_skins': 300,
        'premium_powerups': 500,
        'arena_themes': 450
      };
      
      // Check if player has enough credits
      if (playerCredits >= prices[itemId]) {
        // Deduct credits
        playerCredits -= prices[itemId];
        document.getElementById('playerCredits').textContent = playerCredits;
        
        // Add item to player's inventory
        playerItems[itemId] = true;
        
        // Show success notification
        showNotification('Purchase Successful', `You have purchased the item for ${prices[itemId]} credits!`, 'success');
        
        // Save player data
        savePlayerData();
        
        // Update UI to show owned item
        const button = document.querySelector(`button[onclick="purchaseItem('${itemId}')"]`);
        if (button) {
          button.textContent = 'Owned';
          button.disabled = true;
          button.classList.add('active');
        }
      } else {
        // Show error notification
        showNotification('Insufficient Credits', `You need ${prices[itemId] - playerCredits} more credits to buy this item.`, 'error');
      }
    }
    
    function savePlayerData() {
      // Save player data to localStorage
      const playerData = {
        name: playerName,
        avatar: playerAvatar,
        credits: playerCredits,
        items: playerItems
      };
      
      localStorage.setItem('cosmicPongPlayerData', JSON.stringify(playerData));
    }
    
    function loadPlayerData() {
      // Load player data from localStorage
      const savedData = localStorage.getItem('cosmicPongPlayerData');
      if (savedData) {
        const data = JSON.parse(savedData);
        playerName = data.name || 'Player';
        playerAvatar = data.avatar || 'cyan';
        playerCredits = data.credits || 1000;
        playerItems = data.items || {};
        
        // Update UI
        document.getElementById('playerName').value = playerName;
        document.getElementById('playerAvatar').value = playerAvatar;
        document.getElementById('playerCredits').textContent = playerCredits;
        
        // Update owned items
        for (const item in playerItems) {
          if (playerItems[item]) {
            const button = document.querySelector(`button[onclick="purchaseItem('${item}')"]`);
            if (button) {
              button.textContent = 'Owned';
              button.disabled = true;
              button.classList.add('active');
            }
          }
        }
      }
    }
    
    function loadSettings() {
      // Load settings from localStorage
      const savedSettings = localStorage.getItem('cosmicPongSettings');
      if (savedSettings) {
        const data = JSON.parse(savedSettings);
        
        // Merge saved settings with defaults
        settings = {
          ...settings,
          ...data
        };
        
        // Update UI to reflect loaded settings
        updateSettingsUI();
      }
      
      // Also load player data
      loadPlayerData();
    }
    
    function saveSettings() {
      // Save current settings to localStorage
      localStorage.setItem('cosmicPongSettings', JSON.stringify(settings));
      showNotification('Settings Saved', 'Your settings have been saved.', 'success');
    }
    
    function updateSettingsUI() {
      // Update sliders and form elements to match current settings
      
      // Game settings
      document.getElementById('gameSpeed').value = settings.game.gameSpeed;
      document.getElementById('gameSpeedValue').textContent = settings.game.gameSpeed;
      
      document.getElementById('baseBallSpeed').value = settings.game.baseBallSpeed;
      document.getElementById('baseBallSpeedValue').textContent = settings.game.baseBallSpeed;
      
      document.getElementById('maxPoints').value = settings.game.maxPoints;
      document.getElementById('maxPointsValue').textContent = settings.game.maxPoints;
      
      document.getElementById('powerUpFrequency').value = settings.game.powerUpFrequency;
      document.getElementById('powerUpFrequencyValue').textContent = `${settings.game.powerUpFrequency / 1000}s`;
      
      document.getElementById('extraSpeedFactor').value = settings.game.extraSpeedFactor;
      document.getElementById('extraSpeedFactorValue').textContent = settings.game.extraSpeedFactor;
      
      document.getElementById('randomnessLevel').value = settings.game.randomnessLevel;
      document.getElementById('randomnessLevelValue').textContent = settings.game.randomnessLevel;
      
      // AI settings
      document.getElementById('leftDifficulty').value = settings.ai.leftDifficulty;
      document.getElementById('rightDifficulty').value = settings.ai.rightDifficulty;
      
      // Graphics settings
      document.getElementById('graphicsQuality').value = settings.graphics.quality;
      const qualities = ['Low', 'Medium', 'High'];
      document.getElementById('graphicsQualityValue').textContent = qualities[settings.graphics.quality];
      
      document.getElementById('enableParticles').checked = settings.graphics.enableParticles;
      document.getElementById('enableBloom').checked = settings.graphics.enableBloom;
      document.getElementById('enableShadows').checked = settings.graphics.enableShadows;
      
      // Sound settings
      document.getElementById('masterVolume').value = settings.sound.masterVolume;
      document.getElementById('masterVolumeValue').textContent = `${Math.round(settings.sound.masterVolume * 100)}%`;
      
      document.getElementById('sfxVolume').value = settings.sound.sfxVolume;
      document.getElementById('sfxVolumeValue').textContent = `${Math.round(settings.sound.sfxVolume * 100)}%`;
      
      document.getElementById('musicVolume').value = settings.sound.musicVolume;
      document.getElementById('musicVolumeValue').textContent = `${Math.round(settings.sound.musicVolume * 100)}%`;
      
      document.getElementById('enableMusic').checked = settings.sound.enableMusic;
      
      // Power-up settings
      document.getElementById('powerUpDurationFactor').value = settings.powerUps.durationFactor;
      document.getElementById('powerUpDurationFactorValue').textContent = `${settings.powerUps.durationFactor}x`;
      
      document.getElementById('powerUpStrengthFactor').value = settings.powerUps.strengthFactor;
      document.getElementById('powerUpStrengthFactorValue').textContent = `${settings.powerUps.strengthFactor}x`;
      
      // Power-up toggles
      for (const type in settings.powerUps.enabled) {
        const checkbox = document.getElementById(`toggle${type.charAt(0).toUpperCase() + type.slice(1)}`);
        if (checkbox) {
          checkbox.checked = settings.powerUps.enabled[type];
        }
      }
      
      // Power-up chances
      for (const type in settings.powerUps.chances) {
        const slider = document.getElementById(`${type}Chance`);
        const display = document.getElementById(`${type}ChanceValue`);
        if (slider && display) {
          slider.value = settings.powerUps.chances[type];
          display.textContent = `${settings.powerUps.chances[type]}%`;
        }
      }
    }
    
    function applySettings() {
      // Read all settings from UI
      
      // Game settings
      settings.game.gameSpeed = parseFloat(document.getElementById('gameSpeed').value);
      settings.game.baseBallSpeed = parseFloat(document.getElementById('baseBallSpeed').value);
      settings.game.maxPoints = parseInt(document.getElementById('maxPoints').value);
      settings.game.powerUpFrequency = parseInt(document.getElementById('powerUpFrequency').value);
      settings.game.extraSpeedFactor = parseFloat(document.getElementById('extraSpeedFactor').value);
      settings.game.randomnessLevel = parseInt(document.getElementById('randomnessLevel').value);
      
      // AI settings
      settings.ai.leftDifficulty = document.getElementById('leftDifficulty').value;
      settings.ai.rightDifficulty = document.getElementById('rightDifficulty').value;
      
      // Graphics settings
      settings.graphics.quality = parseInt(document.getElementById('graphicsQuality').value);
      settings.graphics.enableParticles = document.getElementById('enableParticles').checked;
      settings.graphics.enableBloom = document.getElementById('enableBloom').checked;
      settings.graphics.enableShadows = document.getElementById('enableShadows').checked;
      
      // Sound settings
      settings.sound.masterVolume = parseFloat(document.getElementById('masterVolume').value);
      settings.sound.sfxVolume = parseFloat(document.getElementById('sfxVolume').value);
      settings.sound.musicVolume = parseFloat(document.getElementById('musicVolume').value);
      settings.sound.enableMusic = document.getElementById('enableMusic').checked;
      
      // Apply settings
      saveSettings();
      
      // Update game with new settings
      applyGameSettings();
      
      // Show notification
      showNotification('Settings Applied', 'Your settings have been applied to the game.', 'success');
    }
    
    function applyGameSettings() {
      // Apply renderer settings
      renderer.shadowMap.enabled = settings.graphics.enableShadows;
      
      // Apply sound settings
      for (const sound in sounds) {
        sounds[sound].volume(settings.sound[sound === 'music' ? 'musicVolume' : 'sfxVolume'] * settings.sound.masterVolume);
      }
      
      // Toggle music based on settings
      if (settings.sound.enableMusic && gameState === 'playing') {
        if (!sounds.music.playing()) {
          sounds.music.play();
        }
      } else {
        sounds.music.pause();
      }
      
      // Apply power-up settings
      // These will take effect the next time power-ups are spawned
      
      // Apply AI difficulty settings
      leftPaddle.userData.difficulty = settings.ai.leftDifficulty;
      rightPaddle.userData.difficulty = settings.ai.rightDifficulty;
      
      // Update ball speed
      ball.userData.baseSpeed = settings.game.baseBallSpeed;
      
      // Update graphics quality
      // Higher quality settings would adjust particle counts, shadow quality, etc.
    }
    
    function applyPowerUpSettings() {
      // Read power-up settings from UI
      
      // Duration and strength factors
      settings.powerUps.durationFactor = parseFloat(document.getElementById('powerUpDurationFactor').value);
      settings.powerUps.strengthFactor = parseFloat(document.getElementById('powerUpStrengthFactor').value);
      
      // Enabled power-ups
      for (const type in settings.powerUps.enabled) {
        const checkbox = document.getElementById(`toggle${type.charAt(0).toUpperCase() + type.slice(1)}`);
        if (checkbox) {
          settings.powerUps.enabled[type] = checkbox.checked;
        }
      }
      
      // Power-up chances
      for (const type in settings.powerUps.chances) {
        const slider = document.getElementById(`${type}Chance`);
        if (slider) {
          settings.powerUps.chances[type] = parseInt(slider.value);
        }
      }
      
      // Save settings
      saveSettings();
      
      // Show notification
      showNotification('Power-Up Settings Applied', 'Your power-up settings have been applied.', 'success');
    }
    
    function resetSettings() {
      // Reset to default settings
      settings = {
        game: {
          gameSpeed: 2.2,
          baseBallSpeed: 4,
          maxPoints: 10,
          powerUpFrequency: 5000,
          extraSpeedFactor: 0.05,
          randomnessLevel: 15
        },
        ai: {
          leftDifficulty: 'normal',
          rightDifficulty: 'normal'
        },
        graphics: {
          quality: 1,
          enableParticles: true,
          enableBloom: true,
          enableShadows: true
        },
        sound: {
          masterVolume: 0.8,
          sfxVolume: 0.8,
          musicVolume: 0.5,
          enableMusic: true
        },
        powerUps: {
          durationFactor: 1.0,
          strengthFactor: 1.0,
          enabled: {
            speed: true,
            ballSpeed: true,
            shrink: true,
            shield: true,
            magnet: true,
            giant: true,
            ghost: true,
            multiBall: true,
            freeze: true,
            gravity: true,
            timeSlow: true,
            teleport: true,
            superShot: true,
            mirror: true,
            obstacle: true
          },
          chances: {
            speed: 10,
            ballSpeed: 10,
            shrink: 10,
            shield: 10,
            magnet: 10,
            giant: 10,
            ghost: 10,
            multiBall: 10,
            freeze: 10,
            gravity: 10,
            timeSlow: 10,
            teleport: 10,
            superShot: 10,
            mirror: 10,
            obstacle: 10
          }
        }
      };
      
      // Update UI
      updateSettingsUI();
      
      // Apply settings
      applyGameSettings();
      
      // Show notification
      showNotification('Settings Reset', 'All settings have been reset to defaults.', 'info');
    }
    
    function resetPowerUpSettings() {
      // Reset to default power-up settings
      settings.powerUps = {
        durationFactor: 1.0,
        strengthFactor: 1.0,
        enabled: {
          speed: true,
          ballSpeed: true,
          shrink: true,
          shield: true,
          magnet: true,
          giant: true,
          ghost: true,
          multiBall: true,
          freeze: true,
          gravity: true,
          timeSlow: true,
          teleport: true,
          superShot: true,
          mirror: true,
          obstacle: true
        },
        chances: {
          speed: 10,
          ballSpeed: 10,
          shrink: 10,
          shield: 10,
          magnet: 10,
          giant: 10,
          ghost: 10,
          multiBall: 10,
          freeze: 10,
          gravity: 10,
          timeSlow: 10,
          teleport: 10,
          superShot: 10,
          mirror: 10,
          obstacle: 10
        }
      };
      
      // Update UI
      document.getElementById('powerUpDurationFactor').value = settings.powerUps.durationFactor;
      document.getElementById('powerUpDurationFactorValue').textContent = `${settings.powerUps.durationFactor}x`;
      
      document.getElementById('powerUpStrengthFactor').value = settings.powerUps.strengthFactor;
      document.getElementById('powerUpStrengthFactorValue').textContent = `${settings.powerUps.strengthFactor}x`;
      
      // Power-up toggles
      for (const type in settings.powerUps.enabled) {
        const checkbox = document.getElementById(`toggle${type.charAt(0).toUpperCase() + type.slice(1)}`);
        if (checkbox) {
          checkbox.checked = settings.powerUps.enabled[type];
        }
      }
      
      // Power-up chances
      for (const type in settings.powerUps.chances) {
        const slider = document.getElementById(`${type}Chance`);
        const display = document.getElementById(`${type}ChanceValue`);
        if (slider && display) {
          slider.value = settings.powerUps.chances[type];
          display.textContent = `${settings.powerUps.chances[type]}%`;
        }
      }
      
      // Show notification
      showNotification('Power-Up Settings Reset', 'All power-up settings have been reset to defaults.', 'info');
    }
    
    function playSoundWithVolume(sound, volumeScale = 1.0) {
      const volume = settings.sound.sfxVolume * settings.sound.masterVolume * volumeScale;
      sound.volume(volume);
      sound.play();
    }
    
    function showNotification(title, message, type = 'info') {
      const notifContainer = document.getElementById('notificationContainer');
      
      // Create notification element
      const notif = document.createElement('div');
      notif.className = `notification ${type}`;
      
      // Set icon based on type
      let icon;
      switch(type) {
        case 'success': icon = 'fa-check-circle'; break;
        case 'error': icon = 'fa-exclamation-circle'; break;
        case 'warning': icon = 'fa-exclamation-triangle'; break;
        default: icon = 'fa-info-circle';
      }
      
      // Create notification content
      notif.innerHTML = `
        <div class="notification-icon">
          <i class="fas ${icon}"></i>
        </div>
        <div class="notification-content">
          <div class="notification-title">${title}</div>
          <div class="notification-message">${message}</div>
        </div>
      `;
      
      // Add to container
      notifContainer.appendChild(notif);
      
      // Trigger animation
      setTimeout(() => {
        notif.classList.add('show');
      }, 10);
      
      // Remove after a delay
      setTimeout(() => {
        notif.classList.remove('show');
        setTimeout(() => {
          notifContainer.removeChild(notif);
        }, 300);
      }, 5000);
    }
    
    function findMatch() {
      showNotification('Finding Match', 'Searching for opponents...', 'info');
      
      // Set game mode to multiplayer
      setGameMode('multiplayer');
      
      // Show connecting notification
      connectToMultiplayerServer();
    }
    
    function hostPrivateGame() {
      // Generate a random game code
      const gameCode = Math.floor(100000 + Math.random() * 900000);
      
      showNotification('Private Game', `Your game code is: ${gameCode}. Share this with a friend!`, 'success');
      
      // Set game mode to multiplayer
      setGameMode('multiplayer');
      
      // Show waiting notification
      showNotification('Waiting', 'Waiting for opponent to join...', 'info');
    }
    
    function joinPrivateGame() {
      // Prompt for game code
      const code = prompt('Enter the 6-digit game code:');
      
      if (code && code.length === 6) {
        showNotification('Joining Game', `Joining game with code: ${code}...`, 'info');
        
        // Set game mode to multiplayer
        setGameMode('multiplayer');
        
        // Show connecting notification
        connectToMultiplayerServer();
      } else if (code) {
        showNotification('Invalid Code', 'Please enter a valid 6-digit code.', 'error');
      }
    }
    
    function detectDevice() {
      // Check if mobile device
      if (isMobile) {
        // Show mobile controls
        document.getElementById('mobileControls').style.display = 'flex';
        setupMobileControls();
        
        // Show mobile notification
        showNotification('Mobile Detected', 'Touch controls are enabled. You can also tilt your device to move the paddle.', 'info');
        
        // Set up device orientation for tilt controls
        if (window.DeviceOrientationEvent) {
          window.addEventListener('deviceorientation', handleTilt);
        }
      }
    }
    
    function handleTilt(event) {
      // Only use tilt controls for human-controlled paddles
      if (!leftPaddle.userData.isAI) {
        // Use gamma (left/right tilt) for paddle movement
        const tilt = event.gamma;
        
        // Apply deadzone for stability
        if (Math.abs(tilt) < 5) {
          leftPaddle.userData.direction = 0;
        } else {
          // Map tilt to paddle direction (-1 to 1)
          leftPaddle.userData.direction = Math.max(-1, Math.min(1, -tilt / 20));
        }
      }
      
      if (!rightPaddle.userData.isAI && currentGameMode === 'human-vs-human') {
        // For right paddle in two-player mode, use beta (forward/back tilt)
        const tilt = event.beta;
        
        // Apply deadzone for stability
        if (Math.abs(tilt - 45) < 5) { // 45 is roughly neutral phone position
          rightPaddle.userData.direction = 0;
        } else {
          // Map tilt to paddle direction (-1 to 1)
          rightPaddle.userData.direction = Math.max(-1, Math.min(1, (tilt - 45) / 20));
        }
      }
    }
    
    function uploadToGitHub() {
      // This would be implemented with actual GitHub API calls in a real system
      showNotification('GitHub Upload', 'Preparing to upload to GitHub...', 'info');
      
      setTimeout(() => {
        showNotification('GitHub Upload', 'Repository created: cosmic-pong-3d', 'success');
        
        setTimeout(() => {
          showNotification('Deployment', 'Game deployed to https://cosmic-pong-3d.netlify.app', 'success');
        }, 2000);
      }, 3000);
    }
    
    // Animation loop
    let lastTime = 0;
    let consecutiveHitCount = 0;
    
    function animate(currentTime = 0) {
      requestAnimationFrame(animate);
      
      // Calculate delta time in seconds
      const deltaTime = (currentTime - lastTime) / 1000;
      lastTime = currentTime;
      
      // Skip if delta time is too large (tab was inactive)
      if (deltaTime > 0.1) return;
      
      // Update the game state
      switch (gameState) {
        case 'menu':
          // Update menu animation
          updateMenu(deltaTime);
          break;
          
        case 'playing':
          // Update game logic
          updateHumanPaddles();
          updateAIPaddles();
          updatePaddles(deltaTime);
          updateBall(deltaTime);
          updatePowerUps(deltaTime);
          break;
          
        case 'paused':
          // Just render the current state
          break;
          
        case 'finished':
          // Game over animations
          break;
      }
      
      // Render the scene
      renderer.render(scene, camera);
    }
    
    function updateMenu(deltaTime) {
      // Rotate the game field for a cool effect
      if (gameField) {
        gameField.rotation.y += deltaTime * 0.2;
      }
      
      // Make camera slowly move around
      const t = Date.now() * 0.0005;
      camera.position.x = Math.sin(t) * 20;
      camera.position.z = 60 + Math.cos(t) * 10;
      camera.lookAt(0, 0, 0);
      
      // Add some subtle movement to lights
      scene.children.forEach(child => {
        if (child.type === 'PointLight') {
          child.position.y = 10 + Math.sin(t * 0.5 + child.position.x * 0.1) * 5;
        }
      });
    }
    
    // Power-up duration and strength ranges
    const POWER_UP_DURATIONS = {
      speed: [3000, 6500],
      ballSpeed: [3000, 5000],
      shrink: [3000, 5000],
      shield: [8000, 10000],
      magnet: [7000, 9000],
      giant: [5000, 8000],
      ghost: [4000, 7000],
      multiBall: [3000, 6000],
      freeze: [2000, 4000],
      gravity: [5000, 8000],
      timeSlow: [3000, 5000],
      teleport: [2000, 4000],
      superShot: [3000, 6000],
      mirror: [5000, 8000],
      obstacle: [4000, 7000]
    };
    
    const POWER_UP_STRENGTHS = {
      speed: [0.5, 0.9],
      ballSpeed: [0.35, 0.7],
      shrink: [0.3, 0.5],
      shield: [1, 1],
      magnet: [0.8, 1.5],
      giant: [0.7, 1.2],
      ghost: [0.6, 0.9],
      multiBall: [1, 1],
      freeze: [1, 1],
      gravity: [0.5, 1.0],
      timeSlow: [0.3, 0.7],
      teleport: [1, 1],
      superShot: [1.2, 2.0],
      mirror: [1, 1],
      obstacle: [1, 1]
    };
    
    // Make game global
    window.startGame = startGame;
    window.playAgain = playAgain;
    window.showMainMenu = showMainMenu;
    window.purchaseItem = purchaseItem;
    window.applySettings = applySettings;
    window.resetSettings = resetSettings;
    window.applyPowerUpSettings = applyPowerUpSettings;
    window.resetPowerUpSettings = resetPowerUpSettings;
    window.setGameMode = setGameMode;
    window.findMatch = findMatch;
    window.hostPrivateGame = hostPrivateGame;
    window.joinPrivateGame = joinPrivateGame;
    window.uploadToGitHub = uploadToGitHub;
    window.showPanel = showPanel;
    window.hidePanel = hidePanel;
    window.togglePanel = togglePanel;
    
    // Check for mobile device when loading
    window.addEventListener('DOMContentLoaded', () => {
      if (isMobile) {
        detectDevice();
      }
    });
  </script>
  
  <!-- GitHub Deployment Script -->
  <script>
    function deployToGitHub() {
      // This is a simulated deployment to GitHub and Netlify
      const steps = [
        'Creating GitHub repository...',
        'Initializing project files...',
        'Committing game code...',
        'Pushing to main branch...',
        'Setting up Netlify deployment...',
        'Building project...',
        'Deploying to Netlify...',
        'Configuring domain settings...',
        'Testing multiplayer functionality...',
        'Deployment complete!'
      ];
      
      let currentStep = 0;
      showNotification('Deployment Started', 'Preparing to deploy the game...', 'info');
      
      function processNextStep() {
        if (currentStep < steps.length) {
          showNotification('Deployment Progress', steps[currentStep], 'info');
          currentStep++;
          setTimeout(processNextStep, 1500);
        } else {
          // Deployment completed
          showNotification('Deployment Success', 'Game is now live at: cosmic-pong-3d.netlify.app', 'success');
          
          // Add deployment info to the main menu
          const deployInfo = document.createElement('div');
          deployInfo.className = 'deployment-info';
          deployInfo.innerHTML = `
            <div style="margin-top: 20px; text-align: center; padding: 15px; background: rgba(0, 255, 0, 0.1); border-radius: 8px; border: 1px solid var(--success);">
              <p><i class="fas fa-check-circle" style="color: var(--success);"></i> Game is deployed! Visit: <a href="https://cosmic-pong-3d.netlify.app" target="_blank" style="color: var(--primary); text-decoration: underline;">cosmic-pong-3d.netlify.app</a></p>
              <p style="font-size: 14px; margin-top: 10px;">Your game is now online and multiplayer-enabled.</p>
              <div style="font-size: 12px; margin-top: 10px;">Payments to: <span style="color: var(--tertiary);">cartermoyer75@gmail.com</span></div>
            </div>
          `;
          
          document.querySelector('#mainMenu .panel-content').appendChild(deployInfo);
        }
      }
      
      // Start the deployment process
      processNextStep();
    }
    
    // Add deployment button to the main menu when fully loaded
    window.addEventListener('load', function() {
      const btnGroup = document.querySelector('#mainMenu .btn-group');
      if (btnGroup) {
        const deployButton = document.createElement('button');
        deployButton.className = 'cyber-button warning';
        deployButton.textContent = 'DEPLOY GAME';
        deployButton.onclick = deployToGitHub;
        btnGroup.appendChild(deployButton);
      }
    });
  </script>
</body>
</html>
      shield: [1, 1],
      magnet: [0.8, 1.5],
      giant: [0.7, 1.2],
      ghost: [0.6, 0.9],
      multiBall: [1, 1],
      freeze: [1, 1],
      gravity: [0.5, 1.0]
    };
    
    let powerUpInterval;
    let currentGameMode = 'ai-vs-ai'; // Default game mode
    let randomnessLevel = 15;
    let gravityWells = [];
    let multiBalls = [];

    const paddleWidth = 15;
    const paddleHeight = 100;
    const ballRadius = 10;

    // Additional variable for long rallies:
    let consecutiveHitCount = 0;
    let extraHitSpeedFactor = 0.05; // extra speed added per hit

    let leftPaddle = {
      x: 30,
      y: canvas.height / 2 - paddleHeight / 2,
      vy: 0,
      height: paddleHeight,
      speed: 5,
      score: 0,
      successRate: 0.5,
      difficulty: 'normal',
      activePowerUps: [],
      isAI: true
    };

    let rightPaddle = {
      x: canvas.width - 30 - paddleWidth,
      y: canvas.height / 2 - paddleHeight / 2,
      vy: 0,
      height: paddleHeight,
      speed: 5,
      score: 0,
      successRate: 0.5,
      difficulty: 'normal',
      activePowerUps: [],
      isAI: true
    };

    let ball = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      dx: 3,
      dy: 1.5,
      baseSpeed: 3,
      speed: 3,
      lastDx: 3,
      lastDy: 1.5
    };

    // Keyboard controls for human players
    const keys = {
      w: false,
      s: false,
      ArrowUp: false,
      ArrowDown: false
    };

    window.addEventListener('keydown', (e) => {
      if (e.key in keys) {
        keys[e.key] = true;
        e.preventDefault();
      }
    });

    window.addEventListener('keyup', (e) => {
      if (e.key in keys) {
        keys[e.key] = false;
        e.preventDefault();
      }
    });

    function updateHumanPaddles() {
      // Left paddle control with W/S keys
      if (!leftPaddle.isAI) {
        leftPaddle.vy = 0;
        if (keys.w) leftPaddle.vy = -leftPaddle.speed;
        if (keys.s) leftPaddle.vy = leftPaddle.speed;
      }

      // Right paddle control with arrow keys
      if (!rightPaddle.isAI) {
        rightPaddle.vy = 0;
        if (keys.ArrowUp) rightPaddle.vy = -rightPaddle.speed;
        if (keys.ArrowDown) rightPaddle.vy = rightPaddle.speed;
      }
    }

    function setGameMode(mode) {
      // Update UI for active button
      document.querySelectorAll('#gameModeButtons button').forEach(btn => {
        btn.classList.remove('active');
      });
      document.getElementById(mode).classList.add('active');
      
      currentGameMode = mode;
      
      switch(mode) {
        case 'ai-vs-ai':
          leftPaddle.isAI = true;
          rightPaddle.isAI = true;
          scores.textContent = 'Left AI: 0 | Right AI: 0';
          break;
        case 'human-vs-ai':
          leftPaddle.isAI = false;
          rightPaddle.isAI = true;
          scores.textContent = 'Human: 0 | AI: 0';
          break;
        case 'ai-vs-human':
          leftPaddle.isAI = true;
          rightPaddle.isAI = false;
          scores.textContent = 'AI: 0 | Human: 0';
          break;
      }
      
      reset();
    }

    let powerUps = [];
    let powerUpTimer = 0;
    let gameState = 'start';
    let maxPoints;
    let gameSpeed;
    let baseBallSpeed;
    let round = 0;
    let winner = null;
    let gameOverTime = 0;
    let ballSpeedSide = null;
    let ballSpeedActive = false;
    let ballSpeedTimeout = null;
    let effectAnimations = [];
    let stuckCounter = 0;

    // Read settings
    function applySettings() {
      gameSpeed = parseFloat(document.getElementById('gameSpeed').value) || 2.2;
      baseBallSpeed = parseFloat(document.getElementById('baseBallSpeed').value) || 4;
      maxPoints = parseInt(document.getElementById('maxPoints').value) || 10;
      leftPaddle.difficulty = document.getElementById('leftDifficulty').value;
      rightPaddle.difficulty = document.getElementById('rightDifficulty').value;
      
      extraHitSpeedFactor = parseFloat(document.getElementById('extraSpeedFactor').value) || 0.05;
      randomnessLevel = parseInt(document.getElementById('randomnessLevel').value) || 15;
      
      powerUpInterval = parseInt(document.getElementById('powerUpFrequency').value) || 5000;
     
      POWER_UP_CHANCES = {
        speed: document.getElementById('toggleSpeed').checked ? parseFloat(document.getElementById('speedChance').value) : 0,
        ballSpeed: document.getElementById('toggleBallSpeed').checked ? parseFloat(document.getElementById('ballSpeedChance').value) : 0,
        shrink: document.getElementById('toggleShrink').checked ? parseFloat(document.getElementById('shrinkChance').value) : 0,
        shield: document.getElementById('toggleShield').checked ? parseFloat(document.getElementById('shieldChance').value) : 0,
        magnet: document.getElementById('toggleMagnet').checked ? parseFloat(document.getElementById('magnetChance').value) : 0,
        giant: document.getElementById('toggleGiant').checked ? parseFloat(document.getElementById('giantChance').value) : 0,
        ghost: document.getElementById('toggleGhost').checked ? parseFloat(document.getElementById('ghostChance').value) : 0,
        multiBall: document.getElementById('toggleMultiBall').checked ? parseFloat(document.getElementById('multiBallChance').value) : 0,
        freeze: document.getElementById('toggleFreeze').checked ? parseFloat(document.getElementById('freezeChance').value) : 0,
        gravity: document.getElementById('toggleGravity').checked ? parseFloat(document.getElementById('gravityChance').value) : 0
      };
      
      let totalChance = Object.values(POWER_UP_CHANCES).reduce((a, b) => a + b, 0);
      if(totalChance > 0) {
        for (let key in POWER_UP_CHANCES) {
          POWER_UP_CHANCES[key] = POWER_UP_CHANCES[key] / totalChance;
        }
      }
    }

    function loadAIData() {
      const leftData = localStorage.getItem('left_ai_data');
      const rightData = localStorage.getItem('right_ai_data');
      if (leftData) leftPaddle.successRate = JSON.parse(leftData).successRate || 0.5;
      if (rightData) rightPaddle.successRate = JSON.parse(rightData).successRate || 0.5;
    }

    function saveAIData() {
      const leftData = { successRate: leftPaddle.successRate };
      const rightData = { successRate: rightPaddle.successRate };
      localStorage.setItem('left_ai_data', JSON.stringify(leftData));
      localStorage.setItem('right_ai_data', JSON.stringify(rightData));
    }

    // Returns a random x position that is not too close to the center, the paddles, or any existing power-up.
    function getRandomX() {
      let x, attempts = 0;
      do {
        x = Math.random() * (canvas.width - 200) + 100; // margin of 100 on left/right
        if (x > canvas.width / 2 - 30 && x < canvas.width / 2 + 30) continue;
        let tooClose = powerUps.some(pu => Math.abs(pu.x - x) < 50);
        if (tooClose) continue;
        attempts++;
        break;
      } while (attempts < 10);
      return x;
    }

    function spawnPowerUp() {
      let r = Math.random();
      let cumulative = 0;
      let type;
      for (const [key, chance] of Object.entries(POWER_UP_CHANCES)) {
        cumulative += chance;
        if (r <= cumulative) {
          type = key;
          break;
        }
      }
      if (!type) return;
      const x = getRandomX();
      const side = x < canvas.width / 2 ? 'left' : 'right';
      const y = Math.random() * (canvas.height - 60) + 30;
      const durMin = POWER_UP_DURATIONS[type][0];
      const durMax = POWER_UP_DURATIONS[type][1];
      const duration = Math.random() * (durMax - durMin) + durMin;
      const strMin = POWER_UP_STRENGTHS[type][0];
      const strMax = POWER_UP_STRENGTHS[type][1];
      const strength = Math.random() * (strMax - strMin) + strMin;
      powerUps.push({ type, x, y, side, size: 20, duration, strength });
    }

    function moveAI(paddle) {
      const otherPaddle = paddle === leftPaddle ? rightPaddle : leftPaddle;
      const isLeft = paddle === leftPaddle;
      const maxDistance = Math.hypot(canvas.width - paddleWidth - 30, canvas.height);
      const ballDistance = Math.sqrt(Math.pow(ball.x - (isLeft ? paddle.x + paddleWidth : paddle.x), 2) + Math.pow(ball.y - paddle.y, 2));
      const distancePercent = Math.min(1, ballDistance / maxDistance);
      let maxNoise, minNoise;
      switch (paddle.difficulty) {
        case 'easy': maxNoise = 100; minNoise = 50; break;
        case 'normal': maxNoise = 60; minNoise = 20; break;
        case 'hard': maxNoise = 30; minNoise = 10; break;
        case 'insane': maxNoise = 15; minNoise = 2; break;
      }
      const noiseFactor = minNoise + (maxNoise - minNoise) * distancePercent * (1 - paddle.successRate);
      let predictedY = ball.y + (ball.dy / ball.dx) * ((isLeft ? paddle.x + paddleWidth : paddle.x) - ball.x);
      predictedY += (Math.random() - 0.5) * noiseFactor;
      predictedY = Math.max(ballRadius, Math.min(canvas.height - ballRadius, predictedY));
      let desiredHit = 0;
      const ownPowerUp = powerUps.find(p => p.side === (isLeft ? 'left' : 'right'));
      const oppPowerUp = powerUps.find(p => p.side !== (isLeft ? 'left' : 'right'));
      const oppFutureY = otherPaddle.y + otherPaddle.vy * 5;
      if (paddle.successRate > 0.5 && Math.random() < paddle.successRate) {
        if (ownPowerUp) {
          desiredHit = (ownPowerUp.y - predictedY) / (paddle.height / 2);
        } else if (oppPowerUp) {
          desiredHit = (oppPowerUp.y < predictedY ? 1 : -1) * 0.5;
        } else {
          desiredHit = (oppFutureY < predictedY ? 1 : -1) * 0.7;
        }
      }
      desiredHit = Math.max(-1, Math.min(1, desiredHit));
      const targetY = predictedY - (paddle.height / 2) * desiredHit;
      const centerY = paddle.y + paddle.height / 2;
      const difference = targetY - centerY;
      const baseSpeedFactor = 0.5 + 0.5 * (1 - distancePercent);
      let multiplier = 1 + Math.min(Math.abs(difference) / 40, 1);
      const maxVy = paddle.speed * baseSpeedFactor * multiplier;
      paddle.vy = Math.max(-maxVy, Math.min(maxVy, 0.05 * difference));
    }

    function update() {
      // Check max points before any other update.
      if (leftPaddle.score >= maxPoints || rightPaddle.score >= maxPoints) {
        gameState = 'finished';
        return;
      }
      if (gameState === 'gameOver') {
        const targetY = (canvas.height - paddleHeight) / 2;
        leftPaddle.y += (targetY - leftPaddle.y) * 0.1;
        rightPaddle.y += (targetY - rightPaddle.y) * 0.1;
        if (Date.now() - gameOverTime >= 1000 / gameSpeed) {
          resetBall();
          gameState = 'playing';
        }
        return;
      }
      if (gameState !== 'playing') return;

      // Update human paddle controls if applicable
      updateHumanPaddles();

      // Move AI paddles if applicable
      if (leftPaddle.isAI) {
        moveAI(leftPaddle);
      }
      if (rightPaddle.isAI) {
        moveAI(rightPaddle);
      }

      // Apply paddle movements
      leftPaddle.y += leftPaddle.vy;
      rightPaddle.y += rightPaddle.vy;
      leftPaddle.y = Math.max(0, Math.min(canvas.height - leftPaddle.height, leftPaddle.y));
      rightPaddle.y = Math.max(0, Math.min(canvas.height - rightPaddle.height, rightPaddle.y));

      // Process all active power-ups and apply their effects
      [leftPaddle, rightPaddle].forEach(p => {
        // Remove expired power-ups
        p.activePowerUps = p.activePowerUps.filter(pu => Date.now() - pu.startTime < pu.duration);
        
        // Apply speed power-up
        p.speed = 5 * (1 + (p.activePowerUps.some(pu => pu.type === 'speed') ? 
                           p.activePowerUps.find(pu => pu.type === 'speed').strength : 0));
        
        // Apply shrink power-up (reduces paddle height)
        const shrinkEffect = p.activePowerUps.some(pu => pu.type === 'shrink') ? 
                           p.activePowerUps.find(pu => pu.type === 'shrink').strength : 0;
        
        // Apply giant power-up (increases paddle height)
        const giantEffect = p.activePowerUps.some(pu => pu.type === 'giant') ? 
                            p.activePowerUps.find(pu => pu.type === 'giant').strength : 0;
        
        // Calculate final paddle height (apply shrink first, then giant)
        p.height = paddleHeight * (1 - shrinkEffect) * (1 + giantEffect);
        
        // If paddle is frozen, it can't move
        if (p.isFrozen && Date.now() < p.frozenUntil) {
          p.vy = 0;
        }
      });

      ball.baseSpeed += 0.0001;
      let speedFactor = 1;
      if (ballSpeedSide) {
        const opponentSide = ballSpeedSide === 'left' ? 'right' : 'left';
        ballSpeedActive = (opponentSide === 'left' && ball.x < canvas.width / 2) || (opponentSide === 'right' && ball.x > canvas.width / 2);
        if (ballSpeedActive) {
          const pu = (opponentSide === 'left' ? leftPaddle : rightPaddle)
                      .activePowerUps.find(pu => pu.type === 'ballSpeed');
          speedFactor = pu ? 1 + pu.strength : 1;
        }
      }
      ball.speed = ball.baseSpeed * speedFactor;

      // Apply gravity well effects to the ball
      gravityWells.forEach(well => {
        if (Date.now() < well.expiresAt) {
          const dx = well.x - ball.x;
          const dy = well.y - ball.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < well.radius) {
            // Calculate gravitational force
            const force = well.strength * (1 - distance / well.radius) * 0.2;
            ball.dx += (dx / distance) * force;
            ball.dy += (dy / distance) * force;
          }
        }
      });
      
      // Move the ball
      ball.x += ball.dx;
      ball.y += ball.dy;
      
      // Update and process any multi-balls
      multiBalls.forEach(mb => {
        // Apply same physics to multi-balls
        gravityWells.forEach(well => {
          if (Date.now() < well.expiresAt) {
            const dx = well.x - mb.x;
            const dy = well.y - mb.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < well.radius) {
              const force = well.strength * (1 - distance / well.radius) * 0.2;
              mb.dx += (dx / distance) * force;
              mb.dy += (dy / distance) * force;
            }
          }
        });
        
        // Move multi-ball
        mb.x += mb.dx;
        mb.y += mb.dy;
        
        // Wall collisions for multi-balls
        if (mb.y <= ballRadius || mb.y >= canvas.height - ballRadius) {
          mb.dy = -mb.dy;
        }
        
        // Paddle collisions for multi-balls (simplified)
        const mbHitLeft = mb.x - ballRadius <= leftPaddle.x + paddleWidth &&
                        mb.x > leftPaddle.x &&
                        mb.y >= leftPaddle.y && mb.y <= leftPaddle.y + leftPaddle.height;
                        
        const mbHitRight = mb.x + ballRadius >= rightPaddle.x &&
                         mb.x < rightPaddle.x + paddleWidth &&
                         mb.y >= rightPaddle.y && mb.y <= rightPaddle.y + rightPaddle.height;
                         
        if (mbHitLeft) {
          mb.dx = Math.abs(mb.dx) * (1 + Math.random() * 0.2);
          mb.dy += (Math.random() - 0.5) * 2;
        } else if (mbHitRight) {
          mb.dx = -Math.abs(mb.dx) * (1 + Math.random() * 0.2);
          mb.dy += (Math.random() - 0.5) * 2;
        }
      });

      // Wall collisions for main ball
      if (ball.y <= ballRadius || ball.y >= canvas.height - ballRadius) {
        ball.dy = -ball.dy;
        // Add randomness to the bounce
        ball.dy += (Math.random() - 0.5) * (randomnessLevel / 50);
        
        if (leftPaddle.isAI) {
          moveAI(leftPaddle);
        }
        if (rightPaddle.isAI) {
          moveAI(rightPaddle);
        }
      }

      // Paddle collision detection and long-rally speed boost.
      const hitLeft = ball.x - ballRadius <= leftPaddle.x + paddleWidth &&
                      ball.x > leftPaddle.x &&
                      ball.y >= leftPaddle.y && ball.y <= leftPaddle.y + leftPaddle.height;
                      
      const hitRight = ball.x + ballRadius >= rightPaddle.x &&
                       ball.x < rightPaddle.x + paddleWidth &&
                       ball.y >= rightPaddle.y && ball.y <= rightPaddle.y + rightPaddle.height;
                       
      if (hitLeft || hitRight) {
        consecutiveHitCount++; // Increment consecutive hits
        const paddle = hitLeft ? leftPaddle : rightPaddle;
        
        // More randomness in the bounce angle
        const relativeHit = (ball.y - paddle.y - paddle.height / 2) / (paddle.height / 2);
        // Add randomness factor based on settings
        const randomFactor = (Math.random() - 0.5) * (randomnessLevel / 100) * Math.PI;
        let theta = relativeHit * (70 * Math.PI / 180) + randomFactor;
        
        // Increase speed based on rally length (quadratic growth for longer rallies)
        const rallyFactor = Math.min(5, 1 + Math.pow(consecutiveHitCount / 10, 2));
        const extraSpeed = consecutiveHitCount * extraHitSpeedFactor * rallyFactor;
        
        // Add paddle movement influence
        const newSpeed = ball.speed + Math.abs(paddle.vy) * 0.3 + extraSpeed;
        
        // Calculate new velocity with more variation
        const newVx = (hitLeft ? 1 : -1) * newSpeed * Math.cos(theta);
        const newVy = newSpeed * Math.sin(theta);
        
        // Apply the new velocity
        ball.dx = newVx;
        ball.dy = newVy;
        ball.speed = newSpeed;
        
        // Special effects for ghost ball
        if (ball.isGhost) {
          // Ghost ball flickers or has special effects
          ball.ghostOpacity = 0.8;
        }
      }

      // Check collision with power-ups.
      for (let i = powerUps.length - 1; i >= 0; i--) {
        const pu = powerUps[i];
        if (Math.hypot(ball.x - pu.x, ball.y - pu.y) < ballRadius + pu.size / 2) {
          // Determine which paddle gets the effect (negative effects go to opponent)
          const negativeEffects = ['shrink', 'ballSpeed', 'freeze'];
          const selfPaddle = pu.side === 'left' ? leftPaddle : rightPaddle;
          const oppPaddle = pu.side === 'left' ? rightPaddle : leftPaddle;
          const targetPaddle = negativeEffects.includes(pu.type) ? oppPaddle : selfPaddle;
          
          // Handle existing effects
          const existingEffect = targetPaddle.activePowerUps.find(e => e.type === pu.type);
          if (existingEffect && !['shield', 'magnet', 'multiBall', 'gravity'].includes(pu.type)) {
            existingEffect.duration += pu.duration;
          } 
          // Handle new effects
          else {
            switch(pu.type) {
              case 'speed':
              case 'shrink':
              case 'ballSpeed':
              case 'giant':
                targetPaddle.activePowerUps.push({ 
                  type: pu.type, 
                  startTime: Date.now(), 
                  duration: pu.duration, 
                  strength: pu.strength 
                });
                
                if (pu.type === 'ballSpeed') {
                  ballSpeedSide = pu.side;
                  if (ballSpeedTimeout) clearTimeout(ballSpeedTimeout);
                  ballSpeedTimeout = setTimeout(() => {
                    ballSpeedSide = null;
                    ballSpeedTimeout = null;
                    targetPaddle.activePowerUps = targetPaddle.activePowerUps.filter(p => p.type !== 'ballSpeed');
                  }, pu.duration);
                }
                break;
                
              case 'shield':
                let existingShield = targetPaddle.activePowerUps.find(e => e.type === 'shield');
                if (existingShield) {
                  existingShield.count = (existingShield.count || 1) + 1;
                } else {
                  targetPaddle.activePowerUps.push({ 
                    type: 'shield', 
                    startTime: Date.now(), 
                    duration: pu.duration, 
                    count: 1 
                  });
                }
                break;
                
              case 'magnet':
                let existingMagnet = targetPaddle.activePowerUps.find(e => e.type === 'magnet');
                if(existingMagnet) {
                  existingMagnet.duration += pu.duration;
                } else {
                  targetPaddle.activePowerUps.push({ 
                    type: 'magnet', 
                    startTime: Date.now(), 
                    duration: pu.duration, 
                    strength: pu.strength 
                  });
                }
                break;
                
              case 'ghost':
                // Make ball semi-transparent and harder to track
                ball.isGhost = true;
                ball.ghostOpacity = 0.4;
                setTimeout(() => {
                  ball.isGhost = false;
                  ball.ghostOpacity = 1;
                }, pu.duration);
                break;
                
              case 'multiBall':
                // Create an additional ball
                let newBall = {
                  x: ball.x,
                  y: ball.y,
                  dx: -ball.dx * 0.9,
                  dy: ball.dy * 1.1,
                  baseSpeed: ball.baseSpeed,
                  speed: ball.speed,
                  isMultiBall: true
                };
                multiBalls.push(newBall);
                // Remove the multi-ball after duration
                setTimeout(() => {
                  multiBalls = multiBalls.filter(b => b !== newBall);
                }, pu.duration);
                break;
                
              case 'freeze':
                // Freeze opponent paddle
                targetPaddle.isFrozen = true;
                targetPaddle.frozenUntil = Date.now() + pu.duration;
                targetPaddle.activePowerUps.push({ 
                  type: 'freeze', 
                  startTime: Date.now(), 
                  duration: pu.duration
                });
                // Unfreeze after duration
                setTimeout(() => {
                  targetPaddle.isFrozen = false;
                  targetPaddle.activePowerUps = targetPaddle.activePowerUps.filter(p => p.type !== 'freeze');
                }, pu.duration);
                break;
                
              case 'gravity':
                // Create a gravity well in the opponent's half
                const wellX = oppPaddle === leftPaddle ? 
                  canvas.width / 4 : 
                  canvas.width * 3 / 4;
                const well = {
                  x: wellX,
                  y: canvas.height / 2,
                  strength: pu.strength,
                  radius: 80,
                  expiresAt: Date.now() + pu.duration
                };
                gravityWells.push(well);
                // Remove well after duration
                setTimeout(() => {
                  gravityWells = gravityWells.filter(w => w !== well);
                }, pu.duration);
                break;
            }
          }
          effectAnimations.push({ x: pu.x, y: pu.y, type: pu.type, startTime: Date.now() });
          powerUps.splice(i, 1);
        }
      }

      // Scoring: when ball goes off-screen.
      if (ball.x < 0) {
        let shieldEffect = leftPaddle.activePowerUps.find(e => e.type === 'shield');
        if (shieldEffect) {
          if (shieldEffect.count > 1) {
            shieldEffect.count--;
          } else {
            leftPaddle.activePowerUps = leftPaddle.activePowerUps.filter(e => e.type !== 'shield');
          }
          ball.dx = Math.abs(ball.dx);
          ball.x = ballRadius;
          if (leftPaddle.isAI) saveAIData();
        } else {
          rightPaddle.score++;
          winner = 'right';
          gameOverTime = Date.now();
          gameState = 'gameOver';
          if (leftPaddle.isAI || rightPaddle.isAI) saveAIData();
          consecutiveHitCount = 0;
          ball.speed = ball.baseSpeed;
          updateScoreDisplay();
        }
      } else if (ball.x > canvas.width) {
        let shieldEffect = rightPaddle.activePowerUps.find(e => e.type === 'shield');
        if (shieldEffect) {
          if (shieldEffect.count > 1) {
            shieldEffect.count--;
          } else {
            rightPaddle.activePowerUps = rightPaddle.activePowerUps.filter(e => e.type !== 'shield');
          }
          ball.dx = -Math.abs(ball.dx);
          ball.x = canvas.width - ballRadius;
          if (rightPaddle.isAI) saveAIData();
        } else {
          leftPaddle.score++;
          winner = 'left';
          gameOverTime = Date.now();
          gameState = 'gameOver';
          if (leftPaddle.isAI || rightPaddle.isAI) saveAIData();
          consecutiveHitCount = 0;
          ball.speed = ball.baseSpeed;
          updateScoreDisplay();
        }
      }

      // Apply Magnet effect.
      if (leftPaddle.activePowerUps.some(e => e.type === 'magnet')) {
        let magnetEffect = leftPaddle.activePowerUps.find(e => e.type === 'magnet');
        if (ball.x < canvas.width / 2) {
          let targetY = leftPaddle.y + leftPaddle.height / 2;
          let diff = targetY - ball.y;
          ball.dy += diff * (magnetEffect.strength * 0.0005);
        }
      }
      if (rightPaddle.activePowerUps.some(e => e.type === 'magnet')) {
        let magnetEffect = rightPaddle.activePowerUps.find(e => e.type === 'magnet');
        if (ball.x > canvas.width / 2) {
          let targetY = rightPaddle.y + rightPaddle.height / 2;
          let diff = targetY - ball.y;
          ball.dy += diff * (magnetEffect.strength * 0.0005);
        }
      }

      // Only move AI paddles if they are AI-controlled
      if (leftPaddle.isAI) {
        moveAI(leftPaddle);
      }
      if (rightPaddle.isAI) {
        moveAI(rightPaddle);
      }

      powerUpTimer += 16.67;
      if (powerUpTimer >= powerUpInterval) {
        spawnPowerUp();
        powerUpTimer = 0;
      }
      effectAnimations = effectAnimations.filter(ea => Date.now() - ea.startTime < 500);
     
      // Handle balls that get stuck or move horizontally
      if (ball.y < ballRadius + 10 || ball.y > canvas.height - ballRadius - 10 || 
          Math.abs(ball.dy) < 0.5) {
        stuckCounter++;
      } else {
        stuckCounter = 0;
      }
      
      if (stuckCounter > (60 / gameSpeed)) {
        let newSpeed = ball.speed;
        // Add more randomness to unstuck the ball
        let angle = (Math.random() * (Math.PI / 2)) - (Math.PI / 4);
        ball.dx = newSpeed * Math.cos(angle) * (ball.dx < 0 ? -1 : 1);
        ball.dy = newSpeed * Math.sin(angle);
        stuckCounter = 0;
      }
      
      // Make multi-balls more interesting by adjusting their trajectory occasionally
      multiBalls.forEach(mb => {
        if (Math.random() < 0.02) { // 2% chance per frame to adjust trajectory
          let speed = Math.sqrt(mb.dx * mb.dx + mb.dy * mb.dy);
          let angle = Math.atan2(mb.dy, mb.dx) + (Math.random() - 0.5) * Math.PI / 4;
          mb.dx = speed * Math.cos(angle);
          mb.dy = speed * Math.sin(angle);
        }
        
        // Check if multi-ball is off-screen (scoring)
        if (mb.x < 0) {
          rightPaddle.score++;
          multiBalls = multiBalls.filter(b => b !== mb);
          updateScoreDisplay();
        } else if (mb.x > canvas.width) {
          leftPaddle.score++;
          multiBalls = multiBalls.filter(b => b !== mb);
          updateScoreDisplay();
        }
      });
    }

    function updateScoreDisplay() {
      switch(currentGameMode) {
        case 'ai-vs-ai':
          scores.textContent = `Left AI: ${leftPaddle.score} | Right AI: ${rightPaddle.score}`;
          break;
        case 'human-vs-ai':
          scores.textContent = `Human: ${leftPaddle.score} | AI: ${rightPaddle.score}`;
          break;
        case 'ai-vs-human':
          scores.textContent = `AI: ${leftPaddle.score} | Human: ${rightPaddle.score}`;
          break;
      }
    }

    function resetBall() {
      ball.x = canvas.width / 2;
      ball.y = canvas.height / 2;
      const angle = (Math.random() - 0.5) * Math.PI / 2 + (Math.random() - 0.5) * 0.1;
      ball.dx = ball.baseSpeed * Math.cos(angle) * (Math.random() < 0.5 ? 1 : -1);
      ball.dy = ball.baseSpeed * Math.sin(angle) / 2;
      ballSpeedActive = false;
      
      if (leftPaddle.isAI) {
        moveAI(leftPaddle);
      }
      if (rightPaddle.isAI) {
        moveAI(rightPaddle);
      }
    }

    function render() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw center line
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Draw center circle
      ctx.beginPath();
      ctx.arc(canvas.width / 2, canvas.height / 2, 50, 0, Math.PI * 2);
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.stroke();

      [leftPaddle, rightPaddle].forEach(p => {
        if (p.activePowerUps.length > 0) {
          const latestEffect = p.activePowerUps[p.activePowerUps.length - 1].type;
          let glowColor;
          if (latestEffect === 'speed') glowColor = 'yellow';
          else if (latestEffect === 'ballSpeed') glowColor = 'red';
          else if (latestEffect === 'shield') glowColor = 'blue';
          else if (latestEffect === 'magnet') glowColor = 'green';
          else if (latestEffect === 'shrink') glowColor = 'purple';
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 15;
        }
        if (gameState === 'gameOver') {
          ctx.shadowColor = winner === (p === leftPaddle ? 'left' : 'right') ? 'green' : 'red';
          ctx.shadowBlur = 20;
        }
        
        // Draw paddle with rounded corners
        const radius = 5;
        ctx.fillStyle = '#00b4db';
        ctx.beginPath();
        ctx.moveTo(p.x + radius, p.y);
        ctx.lineTo(p.x + paddleWidth - radius, p.y);
        ctx.arcTo(p.x + paddleWidth, p.y, p.x + paddleWidth, p.y + radius, radius);
        ctx.lineTo(p.x + paddleWidth, p.y + p.height - radius);
        ctx.arcTo(p.x + paddleWidth, p.y + p.height, p.x + paddleWidth - radius, p.y + p.height, radius);
        ctx.lineTo(p.x + radius, p.y + p.height);
        ctx.arcTo(p.x, p.y + p.height, p.x, p.y + p.height - radius, radius);
        ctx.lineTo(p.x, p.y + radius);
        ctx.arcTo(p.x, p.y, p.x + radius, p.y, radius);
        ctx.closePath();
        ctx.fill();
        
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      });

      // Draw the main ball with effects (ghost, etc.)
      ctx.save();
      
      // Apply ghost effect if active
      if (ball.isGhost) {
        ctx.globalAlpha = ball.ghostOpacity || 0.4;
      }
      
      const gradient = ctx.createRadialGradient(ball.x, ball.y, 0, ball.x, ball.y, ballRadius);
      gradient.addColorStop(0, '#ffffff');
      gradient.addColorStop(1, ball.isGhost ? 'rgba(200, 200, 255, 0.8)' : '#cccccc');
      ctx.fillStyle = gradient;
      
      // Draw the ball
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
      ctx.fill();
      
      // Add trail effect for fast balls
      if (Math.abs(ball.dx) + Math.abs(ball.dy) > 8) {
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(ball.x - ball.dx/3, ball.y - ball.dy/3, ballRadius * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.globalAlpha = 0.15;
        ctx.beginPath();
        ctx.arc(ball.x - ball.dx/1.5, ball.y - ball.dy/1.5, ballRadius * 0.6, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.restore();
      
      // Draw any multi-balls
      multiBalls.forEach(mb => {
        ctx.save();
        
        // Multi-balls have a cyan glow
        ctx.shadowColor = '#00FFFF';
        ctx.shadowBlur = 10;
        
        const mbGradient = ctx.createRadialGradient(mb.x, mb.y, 0, mb.x, mb.y, ballRadius);
        mbGradient.addColorStop(0, '#FFFFFF');
        mbGradient.addColorStop(1, '#00CCFF');
        ctx.fillStyle = mbGradient;
        
        ctx.beginPath();
        ctx.arc(mb.x, mb.y, ballRadius, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      });
      
      // Draw gravity wells if any
      gravityWells.forEach(well => {
        if (Date.now() < well.expiresAt) {
          ctx.save();
          
          // Create pulsing effect
          const pulseSize = 1 + Math.sin(Date.now() / 200) * 0.1;
          const alpha = 0.6 + Math.sin(Date.now() / 300) * 0.2;
          
          // Draw gravity well
          const gradient = ctx.createRadialGradient(well.x, well.y, 0, well.x, well.y, well.radius * pulseSize);
          gradient.addColorStop(0, 'rgba(128, 0, 255, ' + alpha + ')');
          gradient.addColorStop(0.7, 'rgba(128, 0, 255, ' + alpha * 0.5 + ')');
          gradient.addColorStop(1, 'rgba(128, 0, 255, 0)');
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(well.x, well.y, well.radius * pulseSize, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.restore();
        }
      });

      // Draw power-ups with nice visuals
      powerUps.forEach(p => {
        ctx.save();
        
        if (p.type === 'speed') ctx.fillStyle = '#ffeb3b';
        else if (p.type === 'ballSpeed') ctx.fillStyle = '#f44336';
        else if (p.type === 'shrink') ctx.fillStyle = '#800080';
        else if (p.type === 'shield') ctx.fillStyle = '#2196F3';
        else if (p.type === 'magnet') ctx.fillStyle = '#4CAF50';
        
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 10;
        
        ctx.beginPath();
        
        // Different shapes for different power-ups
        if (p.type === 'speed') { // Star shape for speed
          for (let i = 0; i < 5; i++) {
            const outerAngle = i * 2 * Math.PI / 5;
            const innerAngle = outerAngle + Math.PI / 5;
            
            if (i === 0) {
              ctx.moveTo(p.x + p.size * Math.cos(outerAngle), p.y + p.size * Math.sin(outerAngle));
            } else {
              ctx.lineTo(p.x + p.size * Math.cos(outerAngle), p.y + p.size * Math.sin(outerAngle));
            }
            
            ctx.lineTo(
              p.x + (p.size/2) * Math.cos(innerAngle), 
              p.y + (p.size/2) * Math.sin(innerAngle)
            );
          }
          ctx.closePath();
        } else if (p.type === 'ballSpeed') { // Lightning bolt for ball speed
          ctx.moveTo(p.x - p.size/3, p.y - p.size/2);
          ctx.lineTo(p.x + p.size/6, p.y - p.size/6);
          ctx.lineTo(p.x - p.size/6, p.y + p.size/6);
          ctx.lineTo(p.x + p.size/3, p.y + p.size/2);
          ctx.lineTo(p.x, p.y);
          ctx.closePath();
        } else if (p.type === 'shield') { // Shield shape
          ctx.moveTo(p.x, p.y - p.size/2);
          ctx.lineTo(p.x + p.size/2, p.y - p.size/4);
          ctx.lineTo(p.x + p.size/2, p.y + p.size/4);
          ctx.lineTo(p.x, p.y + p.size/2);
          ctx.lineTo(p.x - p.size/2, p.y + p.size/4);
          ctx.lineTo(p.x - p.size/2, p.y - p.size/4);
          ctx.closePath();
        } else if (p.type === 'magnet') { // Horseshoe magnet
          ctx.moveTo(p.x - p.size/2, p.y - p.size/2);
          ctx.lineTo(p.x - p.size/2, p.y + p.size/2);
          ctx.lineTo(p.x - p.size/4, p.y + p.size/2);
          ctx.lineTo(p.x - p.size/4, p.y - p.size/4);
          ctx.lineTo(p.x + p.size/4, p.y - p.size/4);
          ctx.lineTo(p.x + p.size/4, p.y + p.size/2);
          ctx.lineTo(p.x + p.size/2, p.y + p.size/2);
          ctx.lineTo(p.x + p.size/2, p.y - p.size/2);
          ctx.closePath();
        } else { // Shrink - Arrow pointing inward
          ctx.moveTo(p.x - p.size/2, p.y - p.size/2);
          ctx.lineTo(p.x + p.size/2, p.y - p.size/2);
          ctx.lineTo(p.x + p.size/2, p.y - p.size/4);
          ctx.lineTo(p.x + p.size/4, p.y);
          ctx.lineTo(p.x + p.size/2, p.y + p.size/4);
          ctx.lineTo(p.x + p.size/2, p.y + p.size/2);
          ctx.lineTo(p.x - p.size/2, p.y + p.size/2);
          ctx.lineTo(p.x - p.size/2, p.y + p.size/4);
          ctx.lineTo(p.x - p.size/4, p.y);
          ctx.lineTo(p.x - p.size/2, p.y - p.size/4);
          ctx.closePath();
        }
        
        ctx.fill();
        
        // Add a pulsating effect
        const time = Date.now() * 0.001;
        const pulseSize = Math.sin(time * 3) * 2 + 2;
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        ctx.restore();
      });

      // Draw effect animations
      effectAnimations.forEach(ea => {
        const elapsed = Date.now() - ea.startTime;
        const scale = 1 + elapsed / 250;
        const alpha = 1 - elapsed / 500;
        
        ctx.save();
        ctx.globalAlpha = alpha;
        
        if (ea.type === 'speed') ctx.fillStyle = '#ffeb3b';
        else if (ea.type === 'ballSpeed') ctx.fillStyle = '#f44336';
        else if (ea.type === 'shrink') ctx.fillStyle = '#800080';
        else if (ea.type === 'shield') ctx.fillStyle = '#2196F3';
        else if (ea.type === 'magnet') ctx.fillStyle = '#4CAF50';
        
        ctx.beginPath();
        ctx.arc(ea.x, ea.y, ea.size * scale, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        ctx.restore();
      });

      // Display active power-ups for each player
      [leftPaddle, rightPaddle].forEach((p, index) => {
        const x = index === 0 ? 20 : canvas.width - 120;
        const textAlign = index === 0 ? 'left' : 'right';
        
        ctx.textAlign = textAlign;
        ctx.font = '14px Arial';
        
        p.activePowerUps.forEach((pu, i) => {
          let color;
          if (pu.type === 'speed') color = '#ffeb3b';
          else if (pu.type === 'ballSpeed') color = '#f44336';
          else if (pu.type === 'shrink') color = '#800080';
          else if (pu.type === 'shield') color = '#2196F3';
          else if (pu.type === 'magnet') color = '#4CAF50';
          
          ctx.fillStyle = color;
          
          // Display icon based on power-up type
          if (index === 0) {
            ctx.fillRect(x, 20 + i * 25, 15, 15);
            ctx.fillStyle = '#fff';
            let text = pu.type;
            if (pu.type === 'shield' && pu.count >= 2) text += ' x' + pu.count;
            const timeLeft = Math.ceil((pu.startTime + pu.duration - Date.now()) / 1000);
            ctx.fillText(text + ' (' + timeLeft + 's)', x + 25, 33 + i * 25);
          } else {
            ctx.fillRect(x + 70, 20 + i * 25, 15, 15);
            ctx.fillStyle = '#fff';
            let text = pu.type;
            if (pu.type === 'shield' && pu.count >= 2) text += ' x' + pu.count;
            const timeLeft = Math.ceil((pu.startTime + pu.duration - Date.now()) / 1000);
            ctx.fillText(text + ' (' + timeLeft + 's)', x + 60, 33 + i * 25);
          }
        });
      });
      
      // Reset text alignment
      ctx.textAlign = 'left';

      // Game over point display
      if (gameState === 'gameOver') {
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        
        if (winner === 'left') {
          // Create glowing/pulsing effect
          const glowSize = 5 + Math.sin(Date.now() / 100) * 3;
          
          ctx.shadowColor = 'rgba(0, 255, 0, 0.8)';
          ctx.shadowBlur = glowSize;
          ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
          ctx.fillText('POINT!', canvas.width / 4, canvas.height / 2);
          
          ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
          ctx.shadowBlur = glowSize;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.fillText('MISS', canvas.width * 3 / 4, canvas.height / 2);
        } else {
          // Create glowing/pulsing effect
          const glowSize = 5 + Math.sin(Date.now() / 100) * 3;
          
          ctx.shadowColor = 'rgba(255, 0, 0, 0.8)';
          ctx.shadowBlur = glowSize;
          ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
          ctx.fillText('MISS', canvas.width / 4, canvas.height / 2);
          
          ctx.shadowColor = 'rgba(0, 255, 0, 0.8)';
          ctx.shadowBlur = glowSize;
          ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
          ctx.fillText('POINT!', canvas.width * 3 / 4, canvas.height / 2);
        }
        
        ctx.textAlign = 'left';
        ctx.shadowBlur = 0;
      }
      
      // Display consecutive hit counter for long rallies with visual effects
      if (consecutiveHitCount > 3) {
        ctx.save();
        
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        
        // Change color based on rally length
        let rallyColor;
        if (consecutiveHitCount > 20) {
          // Rainbow effect for incredible rallies
          const hue = (Date.now() / 20) % 360;
          rallyColor = `hsl(${hue}, 100%, 60%)`;
          
          // Add glow for impressive rallies
          ctx.shadowColor = rallyColor;
          ctx.shadowBlur = 10;
        } else if (consecutiveHitCount > 10) {
          rallyColor = '#ff5722'; // Orange for good rallies
          ctx.shadowColor = rallyColor;
          ctx.shadowBlur = 5;
        } else {
          rallyColor = '#ffeb3b'; // Yellow for standard rallies
        }
        
        ctx.fillStyle = rallyColor;
        
        // Pulsing effect for longer rallies
        if (consecutiveHitCount > 10) {
          const scale = 1 + Math.sin(Date.now() / 200) * 0.1;
          ctx.font = `bold ${Math.floor(24 * scale)}px Arial`;
        }
        
        ctx.fillText(`Rally: ${consecutiveHitCount}`, canvas.width / 2, 30);
        
        // Add rally streak flames for higher rallies
        if (consecutiveHitCount > 15) {
          const flameHeight = Math.min(60, consecutiveHitCount * 1.5);
          const baseY = 40;
          
          // Create flame effect
          const flameGradient = ctx.createLinearGradient(0, baseY, 0, baseY + flameHeight);
          flameGradient.addColorStop(0, 'rgba(255, 255, 0, 0.8)');
          flameGradient.addColorStop(0.5, 'rgba(255, 128, 0, 0.6)');
          flameGradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
          
          ctx.fillStyle = flameGradient;
          
          // Draw flame under the text
          const flameWidth = 120 + consecutiveHitCount * 2;
          ctx.beginPath();
          ctx.moveTo(canvas.width / 2 - flameWidth / 2, baseY);
          
          // Create jagged flame effect
          for (let i = 0; i <= 20; i++) {
            const x = canvas.width / 2 - flameWidth / 2 + (flameWidth / 20) * i;
            const heightVariation = Math.sin(i + Date.now() / 100) * 10;
            ctx.lineTo(x, baseY + flameHeight / 2 + heightVariation);
          }
          
          ctx.lineTo(canvas.width / 2 + flameWidth / 2, baseY);
          ctx.closePath();
          ctx.fill();
        }
        
        ctx.restore();
        ctx.textAlign = 'left';
      }
    }

    function reset() {
      loadAIData();
      applySettings();
      consecutiveHitCount = 0; // Reset rally counter
      
      // Clear all timeouts
      const clearTimeouts = window.setTimeout(function() {
        const highestId = window.setTimeout(function() {}, 0);
        for(let i = highestId; i >= 0; i--) {
          window.clearTimeout(i);
        }
      }, 0);
      
      leftPaddle = { 
        ...leftPaddle, 
        x: 30, 
        y: canvas.height / 2 - paddleHeight / 2, 
        vy: 0, 
        height: paddleHeight, 
        speed: 5, 
        score: 0, 
        activePowerUps: [],
        isFrozen: false,
        frozenUntil: 0
      };
      
      rightPaddle = { 
        ...rightPaddle, 
        x: canvas.width - 30 - paddleWidth, 
        y: canvas.height / 2 - paddleHeight / 2, 
        vy: 0, 
        height: paddleHeight, 
        speed: 5, 
        score: 0, 
        activePowerUps: [],
        isFrozen: false,
        frozenUntil: 0
      };
      
      ball = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        dx: baseBallSpeed,
        dy: baseBallSpeed / 2,
        baseSpeed: baseBallSpeed + round * 0.5,
        speed: baseBallSpeed + round * 0.5,
        lastDx: baseBallSpeed,
        lastDy: baseBallSpeed / 2,
        isGhost: false,
        ghostOpacity: 1
      };
      
      // Clear all game state
      powerUps = [];
      multiBalls = [];
      gravityWells = [];
      powerUpTimer = 0;
      winner = null;
      gameOverTime = 0;
      ballSpeedSide = null;
      ballSpeedActive = false;
      ballSpeedTimeout = null;
      effectAnimations = [];
      stuckCounter = 0;
      
      updateScoreDisplay();
      resetBall();
      gameState = 'start';
    }

    // Modified pause so that you can open the pause menu even if the game hasn't started.
    function pause() {
      if (gameState === 'paused') {
        gameState = 'playing';
        loop();
      } else {
        gameState = 'paused';
      }
    }

    function start() {
      if (gameState === 'start' || gameState === 'paused') {
        applySettings();
        gameState = 'playing';
        loop();
      }
    }

    function loop() {
      if (loop.loopId !== null) return;
      let lastTime = performance.now();
      const baseTickRate = 16.67;
      (function frame(currentTime) {
        if (gameState === 'finished') {
          render();
          
          // Display game over message
          ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          
          ctx.font = 'bold 48px Arial';
          ctx.fillStyle = '#00b4db';
          ctx.textAlign = 'center';
          
          if (leftPaddle.score >= maxPoints) {
            if (currentGameMode === 'human-vs-ai') {
              ctx.fillText('You Win!', canvas.width / 2, canvas.height / 2 - 30);
            } else if (currentGameMode === 'ai-vs-human') {
              ctx.fillText('AI Wins!', canvas.width / 2, canvas.height / 2 - 30);
            } else {
              ctx.fillText('Left AI Wins!', canvas.width / 2, canvas.height / 2 - 30);
            }
          } else {
            if (currentGameMode === 'human-vs-ai') {
              ctx.fillText('AI Wins!', canvas.width / 2, canvas.height / 2 - 30);
            } else if (currentGameMode === 'ai-vs-human') {
              ctx.fillText('You Win!', canvas.width / 2, canvas.height / 2 - 30);
            } else {
              ctx.fillText('Right AI Wins!', canvas.width / 2, canvas.height / 2 - 30);
            }
          }
          
          ctx.font = '24px Arial';
          ctx.fillText('Press Reset to play again', canvas.width / 2, canvas.height / 2 + 30);
          
          loop.loopId = null;
          return;
        }
        if (gameState === 'playing' || gameState === 'gameOver') {
          const deltaTime = currentTime - lastTime;
          const tickInterval = baseTickRate / gameSpeed;
          let accumulatedTime = deltaTime;
          while (accumulatedTime >= tickInterval) {
            update();
            accumulatedTime -= tickInterval;
          }
          render();
          lastTime = currentTime - accumulatedTime;
          loop.loopId = requestAnimationFrame(frame);
        } else {
          render();
          loop.loopId = null;
        }
      })(lastTime);
    }
    loop.loopId = null;

    // Initial setup
    loadAIData();
    reset();
    render(); // Draw the initial state
    
    // Show a welcome message
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    ctx.font = 'bold 36px Arial';
    ctx.fillStyle = '#00b4db';
    ctx.textAlign = 'center';
    ctx.fillText('AI Ping Pong', canvas.width / 2, canvas.height / 2 - 60);
    
    ctx.font = '24px Arial';
    ctx.fillText('Select a game mode and press Play!', canvas.width / 2, canvas.height / 2);
    
    ctx.font = '18px Arial';
    ctx.fillText('Left controls: W/S keys', canvas.width / 2, canvas.height / 2 + 50);
    ctx.fillText('Right controls: Arrow Up/Down keys', canvas.width / 2, canvas.height / 2 + 80);
    
    setGameMode('ai-vs-ai'); // Set the default game mode
  </script>
</body>
</html>